patch by Craig Schulstad &lt;craigaschulstad(a)gmail.com&gt;

 Add rudimentary mui resource support 

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 52a17bd7a8c..cd911c17f29 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -512,8 +512,8 @@
 @ stdcall -import FindNLSStringEx(wstr long wstr long wstr long ptr ptr ptr long)
 @ stdcall FindResourceA(long str str)
 @ stdcall FindResourceExA(long str str long)
-@ stdcall -import FindResourceExW(long wstr wstr long)
-@ stdcall -import FindResourceW(long wstr wstr)
+@ stdcall FindResourceExW(long wstr wstr long)
+@ stdcall FindResourceW(long wstr wstr)
 @ stdcall -import FindStringOrdinal(long wstr long wstr long long)
 @ stdcall -import FindVolumeClose(ptr)
 @ stdcall FindVolumeMountPointClose(ptr)
@@ -1068,7 +1068,7 @@
 @ stdcall -import LoadLibraryW(wstr)
 @ stdcall LoadModule(str ptr)
 @ stdcall -import LoadPackagedLibrary(wstr long)
-@ stdcall -import LoadResource(long long)
+@ stdcall  LoadResource(long long)
 # @ stub LoadStringBaseExW
 # @ stub LoadStringBaseW
 @ stdcall -import LocalAlloc(long long)
diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 433366d364b..2f3e440b729 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -1,4 +1,4 @@
-/*
+/*    
  * Modules
  *
  * Copyright 1995 Alexandre Julliard
@@ -33,10 +33,17 @@
 #include "winternl.h"
 #include "kernel_private.h"
 #include "psapi.h"
+#include "winnls.h"
+#include "ddk/ntddk.h"
 
 #include "wine/list.h"
 #include "wine/asm.h"
 #include "wine/debug.h"
+//#include "kernelbase.h"
+#include "wine/list.h"
+#include "wine/asm.h"
+#include "wine/debug.h"
+#include "wine/exception.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(module);
 
@@ -346,3 +353,252 @@ FARPROC WINAPI GetProcAddress( HMODULE hModule, LPCSTR function )
 {
     return get_proc_address_wrapper( hModule, function );
 }
+
+static WCHAR mui_locale[LOCALE_NAME_MAX_LENGTH];
+static BOOL locale_found = 0;
+static BOOL recursion_flag = 0;
+
+#define IS_INTRESOURCE(x)   (((ULONG_PTR)(x) >> 16) == 0)
+
+/* retrieve the resource name to pass to the ntdll functions */
+static NTSTATUS get_res_nameW( LPCWSTR name, UNICODE_STRING *str )
+{
+    if (IS_INTRESOURCE(name))
+    {
+        str->Buffer = ULongToPtr( LOWORD(name) );
+        return STATUS_SUCCESS;
+    }
+    if (name[0] == '#')
+    {
+        ULONG value;
+        RtlInitUnicodeString( str, name + 1 );
+        if (RtlUnicodeStringToInteger( str, 10, &value ) != STATUS_SUCCESS || HIWORD(value))
+            return STATUS_INVALID_PARAMETER;
+        str->Buffer = ULongToPtr(value);
+        return STATUS_SUCCESS;
+    }
+    RtlCreateUnicodeString( str, name );
+    RtlUpcaseUnicodeString( str, str, FALSE );
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************/
+/* get_mui - Acquire an MUI module for the associated resource         */
+/***********************************************************************/
+
+HMODULE get_mui(HMODULE module)
+
+{
+
+    HMODULE mui_module = NULL;
+
+    WCHAR module_name[MAX_PATH], mui_name[MAX_PATH];
+
+    INT i, j, k, l;
+
+    /* Initialize the work strings */
+
+    for (i = 0; i < MAX_PATH; i++) {
+        module_name[i] = 0;
+        mui_name[i] = 0;
+    }
+
+    /* Note - the reference to the Windows file name for an "MUI" file has astructure such as   */
+    /* "C:\Program Files\Application Directory\xx-XX\Application.exe.mui";however, in testing   */
+    /* out the usage of the "GetModuleFileNameW" function, it was determinedthat it works with  */
+    /* a relative Linux file structure such as "xx-XX/Application.exe.mui". */
+
+    /* Acquire the base resource file name */
+
+    if (!(GetModuleFileNameW(module, module_name, MAX_PATH))) return module;
+
+    /*  Stay with the original module reference if this file is not an executable file.*/
+
+    if (!(wcsstr(module_name, L".exe"))) return module;
+
+    /* Acquire the locale name using LCIDToLocaleName.  Since this function utilizes theFindResourceExW function, this */
+    /* sets up a recursive call to this function.  In order to avoid a stack overflowcondition that would be caused by */
+    /* repeated calls, a flag will be set on to return back to the FindResourceExWfunction without again calling the   */
+    /* locale acquisition function. */
+
+    if (!(locale_found)) {
+
+        if (recursion_flag) return module;
+
+        recursion_flag = 1;
+
+        LCIDToLocaleName( GetUserDefaultLCID(), mui_locale, LOCALE_NAME_MAX_LENGTH, 0 );
+
+        recursion_flag = 0;
+
+        locale_found = 1;
+
+    }
+
+    /* Locate the position of the final backslash in the retrieved executable file. */
+
+    j = 0;
+
+    for (i = 0; i < MAX_PATH; i++) {
+
+        if (module_name[i] == 0) break;
+
+        if (module_name[i] == '\\') j = i;
+    }
+
+    /* Set up the work index that will be used to extract just the executable file fromthe fully qualified file name. */
+
+    k = 0;
+
+    for (i = 0; i < MAX_PATH; i++) {
+
+        if (module_name[i] == 0) break;
+
+        /* If work index "j" has been set to -1, then the file portion of thequalified name has been reached and will */
+        /* be copied to the "MUI" file reference. */
+
+        if (j < 0) {
+            mui_name[k] = module_name[i];
+            k++;
+        }
+
+        /* When the position of the final backslash has been reached, add the locale nameas the folder/directory      */
+        /* containing the "MUI" file and reset work index "j" to -1.*/
+
+        if (i >= j && j > 0) {
+            for (l = 0; l < 5; l++) {
+                mui_name[k] = mui_locale[l];
+                k++;
+            }
+            mui_name[k] = '/';
+            k++;
+            j = -1;
+        }
+    }
+
+    /* Finally, append the literal ".mui" onto the file reference. */
+
+    wcscat(mui_name, L".mui");
+
+    /* Now, see if there is an associated "MUI" file and if so use its handlefor the module handle. */
+
+    mui_module = LoadLibraryExW(mui_name, 0, 0);
+
+    if (mui_module) {
+        return mui_module;
+    } else {
+        return module;
+    }
+
+}
+
+/***********************************************************************/
+/* get_res_handle - Isolated call of the LdrFindResource function      */
+/***********************************************************************/
+
+HRSRC get_res_handle(HMODULE module, LPCWSTR type, LPCWSTR name, WORD lang)
+
+{
+    NTSTATUS status;
+    UNICODE_STRING nameW, typeW;
+    LDR_RESOURCE_INFO info;
+    const IMAGE_RESOURCE_DATA_ENTRY *entry = NULL;
+
+    TRACE( "%p %s %s %04x\n", module, debugstr_w(type), debugstr_w(name), lang );
+
+    nameW.Buffer = typeW.Buffer = NULL;
+
+    __TRY
+    {
+        if ((status = get_res_nameW( name, &nameW )) != STATUS_SUCCESS) goto done;
+        if ((status = get_res_nameW( type, &typeW )) != STATUS_SUCCESS) goto done;
+        info.Type = (ULONG_PTR)typeW.Buffer;
+        info.Name = (ULONG_PTR)nameW.Buffer;
+        info.Language = lang;
+        status = LdrFindResource_U( module, &info, 3, &entry );
+    done:
+        if (status != STATUS_SUCCESS) SetLastError( RtlNtStatusToDosError(status) );
+    }
+    __EXCEPT_PAGE_FAULT
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+    }
+    __ENDTRY
+
+    if (!IS_INTRESOURCE(nameW.Buffer)) HeapFree( GetProcessHeap(), 0, nameW.Buffer );
+    if (!IS_INTRESOURCE(typeW.Buffer)) HeapFree( GetProcessHeap(), 0, typeW.Buffer );
+
+    return (HRSRC)entry;
+
+}
+
+/**********************************************************************
+ *	    FindResourceExW  (kernelbase.@)
+ */
+HRSRC WINAPI DECLSPEC_HOTPATCH FindResourceExW( HMODULE module, LPCWSTR type, LPCWSTR name, WORD lang )
+{
+
+    HRSRC rsrc;
+
+    TRACE( "%p %s %s %04x\n", module, debugstr_w(type), debugstr_w(name), lang );
+
+    if (!module) module = GetModuleHandleW( 0 );
+
+    rsrc = get_res_handle(module, type, name, lang);
+
+    if (rsrc) {
+
+        return rsrc;
+
+    } else {
+
+        /* If a resource retrieval failed using the initial module value, attempt to */
+        /* locate an associated MUI file and retry the resource retrieval.           */
+
+        module = get_mui(module);
+
+        rsrc = get_res_handle(module, type, name, lang);
+
+        return rsrc;
+
+    }
+}
+
+
+/**********************************************************************
+ *	    FindResourceW    (kernelbase.@)
+ */
+HRSRC WINAPI DECLSPEC_HOTPATCH FindResourceW( HINSTANCE module, LPCWSTR name, LPCWSTR type )
+{
+    return FindResourceExW( module, type, name, MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ) );
+}
+
+
+/**********************************************************************
+ *	    LoadResource     (kernelbase.@)
+ */
+HGLOBAL WINAPI DECLSPEC_HOTPATCH LoadResource( HINSTANCE module, HRSRC rsrc )
+{
+    void *ret;
+    HMODULE mui_module = NULL;
+
+    TRACE( "%p %p\n", module, rsrc );
+
+    if (!rsrc) return 0;
+    if (!module) module = GetModuleHandleW( 0 );
+
+
+    /* Only check for an MUI reference if the resource handle value is less than the module value, */
+    /* or if an MUI reference was found and the MUI reference and handle value are larger than the */
+    /* module value for the executable file.  That is a signal that the resource handle is to be   */
+    /* associated with the MUI file instead of the executable file.            */
+
+    mui_module = get_mui(module);
+
+    if (((HMODULE)rsrc < module) || ((mui_module > module) && ((HMODULE)rsrc > mui_module))) module = mui_module;
+
+    if (!set_ntstatus( LdrAccessResource( module, (IMAGE_RESOURCE_DATA_ENTRY *)rsrc, &ret, NULL )))
+        return 0;
+    return ret;
+}
+
