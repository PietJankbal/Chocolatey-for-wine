diff --git a/dlls/kernel32/computername.c b/dlls/kernel32/computername.c
index 7c2003664e8..2366533bd60 100644
--- a/dlls/kernel32/computername.c
+++ b/dlls/kernel32/computername.c
@@ -32,9 +32,49 @@
 #include "winnls.h"
 #include "winternl.h"
 #include "wine/exception.h"
+#include "ddk/ntddk.h"
+#include "wine/list.h"
+#include "wine/asm.h"
+#include "wine/debug.h"
+
+#include "wincontypes.h"
+#include "wine/condrv.h"
 
 #include "kernel_private.h"
 
+WINE_DEFAULT_DEBUG_CHANNEL(vvv);
+
+struct pseudo_console
+{
+    HANDLE signal;
+    HANDLE reference;
+    HANDLE process;
+};
+
+extern WCHAR *file_name_AtoW( LPCSTR name, BOOL alloc );
+extern DWORD file_name_WtoA( LPCWSTR src, INT srclen, LPSTR dest, INT destlen );
+extern void init_global_data(void);
+extern void init_startup_info( RTL_USER_PROCESS_PARAMETERS *params );
+extern void init_locale( HMODULE module );
+extern void init_console(void);
+
+extern const WCHAR windows_dir[];
+extern const WCHAR system_dir[];
+
+static const BOOL is_win64 = (sizeof(void *) > sizeof(int));
+extern BOOL is_wow64;
+
+
+
+/* make the kernel32 names available */
+#define HeapAlloc(heap, flags, size) RtlAllocateHeap(heap, flags, size)
+#define HeapReAlloc(heap, flags, ptr, size) RtlReAllocateHeap(heap, flags, ptr, size)
+#define HeapFree(heap, flags, ptr) RtlFreeHeap(heap, flags, ptr)
+
+
+
+
+
 
 /***********************************************************************
  *              GetComputerNameW         (KERNEL32.@)
@@ -119,3 +159,956 @@ BOOL WINAPI DnsHostnameToComputerNameW(LPCWSTR hostname,
 {
     return DnsHostnameToComputerNameExW( hostname, computername, size );
 }
+
+
+
+
+///////////////////////////////////////////////////////////////////////////////////
+
+
+
+
+/* to keep track of LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE file handles */
+struct exclusive_datafile
+{
+    struct list entry;
+    HMODULE     module;
+    HANDLE      file;
+};
+static struct list exclusive_datafile_list = LIST_INIT( exclusive_datafile_list );
+
+static CRITICAL_SECTION exclusive_datafile_list_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &exclusive_datafile_list_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": exclusive_datafile_list_section") }
+};
+static CRITICAL_SECTION exclusive_datafile_list_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+/* MUI Start */
+static WCHAR mui_locale[LOCALE_NAME_MAX_LENGTH];
+static BOOL locale_found = 0;
+static BOOL recursion_flag = 0;
+/* MUI End   */
+
+/***********************************************************************
+ * Modules
+ ***********************************************************************/
+
+
+
+
+/***********************************************************************
+ *	FreeLibrary   (kernelbase.@)
+ */
+BOOL WINAPI DECLSPEC_HOTPATCH FreeLibrary( HINSTANCE module )
+{
+    if (!module)
+    {
+        SetLastError( ERROR_INVALID_HANDLE );
+        return FALSE;
+    }
+
+    if ((ULONG_PTR)module & 3) /* this is a datafile module */
+    {
+        void *ptr = (void *)((ULONG_PTR)module & ~3);
+        if (!RtlImageNtHeader( ptr ))
+        {
+            SetLastError( ERROR_BAD_EXE_FORMAT );
+            return FALSE;
+        }
+        if ((ULONG_PTR)module & 1)
+        {
+            struct exclusive_datafile *file;
+
+            RtlEnterCriticalSection( &exclusive_datafile_list_section );
+            LIST_FOR_EACH_ENTRY( file, &exclusive_datafile_list, struct exclusive_datafile, entry )
+            {
+                if (file->module != module) continue;
+                TRACE( "closing %p for module %p\n", file->file, file->module );
+                CloseHandle( file->file );
+                list_remove( &file->entry );
+                HeapFree( GetProcessHeap(), 0, file );
+                break;
+            }
+            RtlLeaveCriticalSection( &exclusive_datafile_list_section );
+        }
+        return UnmapViewOfFile( ptr );
+    }
+
+    return set_ntstatus( LdrUnloadDll( module ));
+}
+
+/***********************************************************************
+ * Resources
+ ***********************************************************************/
+
+
+#define IS_INTRESOURCE(x)   (((ULONG_PTR)(x) >> 16) == 0)
+
+/* retrieve the resource name to pass to the ntdll functions */
+static NTSTATUS get_res_nameW( LPCWSTR name, UNICODE_STRING *str )
+{
+    if (IS_INTRESOURCE(name))
+    {
+        str->Buffer = ULongToPtr( LOWORD(name) );
+        return STATUS_SUCCESS;
+    }
+    if (name[0] == '#')
+    {
+        ULONG value;
+        RtlInitUnicodeString( str, name + 1 );
+        if (RtlUnicodeStringToInteger( str, 10, &value ) != STATUS_SUCCESS || HIWORD(value))
+            return STATUS_INVALID_PARAMETER;
+        str->Buffer = ULongToPtr(value);
+        return STATUS_SUCCESS;
+    }
+    RtlCreateUnicodeString( str, name );
+    RtlUpcaseUnicodeString( str, str, FALSE );
+    return STATUS_SUCCESS;
+}
+
+
+
+/* MUI Start */
+
+/***********************************************************************/
+/* get_mui - Acquire an MUI module for the associated resource         */
+/***********************************************************************/
+
+HMODULE get_mui(HMODULE module)
+
+{
+
+    HMODULE mui_module = NULL;
+
+    WCHAR module_name[MAX_PATH], mui_name[MAX_PATH];
+
+    INT i, j, k, l;
+
+    /* Initialize the work strings */
+
+    for (i = 0; i < MAX_PATH; i++) {
+        module_name[i] = 0;
+        mui_name[i] = 0;
+    }
+
+    /* Note - the reference to the Windows file name for an "MUI" file has a structure such as   */
+    /* "C:\Program Files\Application Directory\xx-XX\Application.exe.mui"; however, in testing   */
+    /* out the usage of the "GetModuleFileNameW" function, it was determined that it works with  */
+    /* a relative Linux file structure such as "xx-XX/Application.exe.mui". */
+
+    /* Acquire the base resource file name */
+
+    if (!(GetModuleFileNameW(module, module_name, MAX_PATH))) return module;
+
+    /*  Stay with the original module reference if this file is not an executable file. */
+
+    if (!(wcsstr(module_name, L".exe"))) return module;
+
+    /* Acquire the locale name using LCIDToLocaleName.  Since this function utilizes the FindResourceExW function, this */
+    /* sets up a recursive call to this function.  In order to avoid a stack overflow condition that would be caused by */
+    /* repeated calls, a flag will be set on to return back to the FindResourceExW function without again calling the   */
+    /* locale acquisition function. */
+
+    if (!(locale_found)) {
+
+        if (recursion_flag) return module;
+
+        recursion_flag = 1;
+
+        LCIDToLocaleName( GetUserDefaultLCID(), mui_locale, LOCALE_NAME_MAX_LENGTH, 0 );
+
+        recursion_flag = 0;
+
+        locale_found = 1;
+
+    }
+
+    /* Locate the position of the final backslash in the retrieved executable file. */
+
+    j = 0;
+
+    for (i = 0; i < MAX_PATH; i++) {
+
+        if (module_name[i] == 0) break;
+
+        if (module_name[i] == '\\') j = i;
+    }
+
+    /* Set up the work index that will be used to extract just the executable file from the fully qualified file name. */
+
+    k = 0;
+
+    for (i = 0; i < MAX_PATH; i++) {
+
+        if (module_name[i] == 0) break;
+
+        /* If work index "j" has been set to -1, then the file portion of the qualified name has been reached and will */
+        /* be copied to the "MUI" file reference. */
+
+        if (j < 0) {
+            mui_name[k] = module_name[i];
+            k++;
+        }
+
+        /* When the position of the final backslash has been reached, add the locale name as the folder/directory      */
+        /* containing the "MUI" file and reset work index "j" to -1. */
+
+        if (i >= j && j > 0) {
+            for (l = 0; l < 5; l++) {
+                mui_name[k] = mui_locale[l];
+                k++;
+            }
+            mui_name[k] = '/';
+            k++;
+            j = -1;
+        }
+    }
+
+    /* Finally, append the literal ".mui" onto the file reference. */
+
+    wcscat(mui_name, L".mui");
+
+    /* Now, see if there is an associated "MUI" file and if so use its handle for the module handle. */
+
+    mui_module = LoadLibraryExW(mui_name, 0, 0);
+
+    if (mui_module) {
+        return mui_module;
+    } else {
+        return module;
+    }
+
+}
+
+/***********************************************************************/
+/* get_res_handle - Isolated call of the LdrFindResource function      */
+/***********************************************************************/
+
+HRSRC get_res_handle(HMODULE module, LPCWSTR type, LPCWSTR name, WORD lang)
+
+{
+    NTSTATUS status;
+    UNICODE_STRING nameW, typeW;
+    LDR_RESOURCE_INFO info;
+    const IMAGE_RESOURCE_DATA_ENTRY *entry = NULL;
+
+    TRACE( "%p %s %s %04x\n", module, debugstr_w(type), debugstr_w(name), lang );
+
+    nameW.Buffer = typeW.Buffer = NULL;
+
+    __TRY
+    {
+        if ((status = get_res_nameW( name, &nameW )) != STATUS_SUCCESS) goto done;
+        if ((status = get_res_nameW( type, &typeW )) != STATUS_SUCCESS) goto done;
+        info.Type = (ULONG_PTR)typeW.Buffer;
+        info.Name = (ULONG_PTR)nameW.Buffer;
+        info.Language = lang;
+        status = LdrFindResource_U( module, &info, 3, &entry );
+    done:
+        if (status != STATUS_SUCCESS) SetLastError( RtlNtStatusToDosError(status) );
+    }
+    __EXCEPT_PAGE_FAULT
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+    }
+    __ENDTRY
+
+    if (!IS_INTRESOURCE(nameW.Buffer)) HeapFree( GetProcessHeap(), 0, nameW.Buffer );
+    if (!IS_INTRESOURCE(typeW.Buffer)) HeapFree( GetProcessHeap(), 0, typeW.Buffer );
+
+    return (HRSRC)entry;
+
+}
+
+/* MUI End   */
+
+/**********************************************************************
+ *	    FindResourceExW  (kernelbase.@)
+ */
+HRSRC WINAPI DECLSPEC_HOTPATCH FindResourceExW( HMODULE module, LPCWSTR type, LPCWSTR name, WORD lang )
+{
+    /* MUI Start */
+
+    HRSRC rsrc;
+
+    TRACE( "%p %s %s %04x\n", module, debugstr_w(type), debugstr_w(name), lang );
+
+    if (!module) module = GetModuleHandleW( 0 );
+
+    rsrc = get_res_handle(module, type, name, lang);
+
+    if (rsrc) {
+
+        return rsrc;
+
+    } else {
+
+        /* If a resource retrieval failed using the initial module value, attempt to */
+        /* locate an associated MUI file and retry the resource retrieval.           */
+
+        module = get_mui(module);
+
+        rsrc = get_res_handle(module, type, name, lang);
+
+        return rsrc;
+
+    }
+
+    /* MUI End   */
+}
+
+
+
+/**********************************************************************
+ *	    LoadResource     (kernelbase.@)
+ */
+HGLOBAL WINAPI DECLSPEC_HOTPATCH LoadResource( HINSTANCE module, HRSRC rsrc )
+{
+    void *ret;
+	
+	/* MUI Start */
+
+    HMODULE mui_module = NULL;
+
+    /* MUI End   */
+
+    TRACE( "%p %p\n", module, rsrc );
+
+    if (!rsrc) return 0;
+    if (!module) module = GetModuleHandleW( 0 );
+	
+	/* MUI Start */
+
+    /* Only check for an MUI reference if the resource handle value is less than the module value, */
+    /* or if an MUI reference was found and the MUI reference and handle value are larger than the */
+    /* module value for the executable file.  That is a signal that the resource handle is to be   */
+    /* associated with the MUI file instead of the executable file.                                */
+
+    mui_module = get_mui(module);
+
+    if (((HMODULE)rsrc < module) || ((mui_module > module) && ((HMODULE)rsrc > mui_module))) module = mui_module;
+
+    /* MUI End   */
+	
+    if (!set_ntstatus( LdrAccessResource( module, (IMAGE_RESOURCE_DATA_ENTRY *)rsrc, &ret, NULL )))
+        return 0;
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+ //BOOL WINAPI DECLSPEC_HOTPATCH VirtualProtect( void *addr, SIZE_T size, DWORD new_prot, DWORD *old_prot )
+ //{
+   // BOOL ret = VirtualProtectEx( GetCurrentProcess(), addr, size, new_prot, old_prot );
+   // if (old_prot && *old_prot == PAGE_WRITECOPY) *old_prot = PAGE_READWRITE;
+   // return ret;
+ //}
+ 
+ 
+ /**********************************************************************
+ *           CreateProcessW   (kernelbase.@)
+ */
+BOOL WINAPI DECLSPEC_HOTPATCH CreateProcessW( const WCHAR *app_name, WCHAR *cmd_line,
+                                              SECURITY_ATTRIBUTES *process_attr,
+                                              SECURITY_ATTRIBUTES *thread_attr, BOOL inherit, DWORD flags,
+                                              void *env, const WCHAR *cur_dir, STARTUPINFOW *startup_info,
+                                              PROCESS_INFORMATION *info )
+{
+    return CreateProcessInternalW( NULL, app_name, cmd_line, process_attr, thread_attr,
+                                   inherit, flags, env, cur_dir, startup_info, info, NULL );
+}
+
+
+ 
+/***********************************************************************
+ *           find_exe_file
+ */
+static BOOL find_exe_file( const WCHAR *name, WCHAR *buffer, DWORD buflen )
+{
+    WCHAR *load_path;
+    BOOL ret;
+
+    if (!set_ntstatus( RtlGetExePath( name, &load_path ))) return FALSE;
+
+    TRACE( "looking for %s in %s\n", debugstr_w(name), debugstr_w(load_path) );
+
+    ret = (SearchPathW( load_path, name, L".exe", buflen, buffer, NULL ) ||
+           /* not found, try without extension in case it is a Unix app */
+           SearchPathW( load_path, name, NULL, buflen, buffer, NULL ));
+
+    if (ret)  /* make sure it can be opened, SearchPathW also returns directories */
+    {
+        HANDLE handle = CreateFileW( buffer, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_DELETE,
+                                     NULL, OPEN_EXISTING, 0, 0 );
+        if ((ret = (handle != INVALID_HANDLE_VALUE))) CloseHandle( handle );
+    }
+    RtlReleasePath( load_path );
+    return ret;
+}
+
+ 
+/*************************************************************************
+ *               get_file_name
+ *
+ * Helper for CreateProcess: retrieve the file name to load from the
+ * app name and command line. Store the file name in buffer, and
+ * return a possibly modified command line.
+ */
+static WCHAR *get_file_name( WCHAR *cmdline, WCHAR *buffer, DWORD buflen )
+{
+    WCHAR *name, *pos, *first_space, *ret = NULL;
+    const WCHAR *p;
+
+    /* first check for a quoted file name */
+
+    if (cmdline[0] == '"' && (p = wcschr( cmdline + 1, '"' )))
+    {
+        int len = p - cmdline - 1;
+        /* extract the quoted portion as file name */
+        if (!(name = RtlAllocateHeap( GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR) ))) return NULL;
+        memcpy( name, cmdline + 1, len * sizeof(WCHAR) );
+        name[len] = 0;
+
+        if (!find_exe_file( name, buffer, buflen )) goto done;
+        ret = cmdline;  /* no change necessary */
+        goto done;
+    }
+
+    /* now try the command-line word by word */
+
+    if (!(name = RtlAllocateHeap( GetProcessHeap(), 0, (lstrlenW(cmdline) + 1) * sizeof(WCHAR) )))
+        return NULL;
+    pos = name;
+    p = cmdline;
+    first_space = NULL;
+
+    for (;;)
+    {
+        while (*p && *p != ' ' && *p != '\t') *pos++ = *p++;
+        *pos = 0;
+        if (find_exe_file( name, buffer, buflen ))
+        {
+            ret = cmdline;
+            break;
+        }
+        if (!first_space) first_space = pos;
+        if (!(*pos++ = *p++)) break;
+    }
+
+    if (!ret)
+    {
+        SetLastError( ERROR_FILE_NOT_FOUND );
+    }
+    else if (first_space)  /* build a new command-line with quotes */
+    {
+        if (!(ret = HeapAlloc( GetProcessHeap(), 0, (lstrlenW(cmdline) + 3) * sizeof(WCHAR) )))
+            goto done;
+        swprintf( ret, lstrlenW(cmdline) + 3, L"\"%s\"%s", name, p );
+    }
+
+ done:
+    RtlFreeHeap( GetProcessHeap(), 0, name );
+    return ret;
+}
+
+
+/***********************************************************************
+ *           create_process_params
+ */
+static RTL_USER_PROCESS_PARAMETERS *create_process_params( const WCHAR *filename, const WCHAR *cmdline,
+                                                           const WCHAR *cur_dir, void *env, DWORD flags,
+                                                           const STARTUPINFOW *startup )
+{
+    RTL_USER_PROCESS_PARAMETERS *params;
+    UNICODE_STRING imageW, curdirW, cmdlineW, titleW, desktopW, runtimeW, newdirW;
+    WCHAR imagepath[MAX_PATH];
+    WCHAR *envW = env;
+
+    if (!GetLongPathNameW( filename, imagepath, MAX_PATH )) lstrcpynW( imagepath, filename, MAX_PATH );
+    if (!GetFullPathNameW( imagepath, MAX_PATH, imagepath, NULL )) lstrcpynW( imagepath, filename, MAX_PATH );
+
+    if (env && !(flags & CREATE_UNICODE_ENVIRONMENT))  /* convert environment to unicode */
+    {
+        char *e = env;
+        DWORD lenW;
+
+        while (*e) e += strlen(e) + 1;
+        e++;  /* final null */
+        lenW = MultiByteToWideChar( CP_ACP, 0, env, e - (char *)env, NULL, 0 );
+        if ((envW = RtlAllocateHeap( GetProcessHeap(), 0, lenW * sizeof(WCHAR) )))
+            MultiByteToWideChar( CP_ACP, 0, env, e - (char *)env, envW, lenW );
+    }
+
+    newdirW.Buffer = NULL;
+    if (cur_dir)
+    {
+        if (RtlDosPathNameToNtPathName_U( cur_dir, &newdirW, NULL, NULL ))
+            cur_dir = newdirW.Buffer + 4;  /* skip \??\ prefix */
+        else
+            cur_dir = NULL;
+    }
+    RtlInitUnicodeString( &imageW, imagepath );
+    RtlInitUnicodeString( &curdirW, cur_dir );
+    RtlInitUnicodeString( &cmdlineW, cmdline );
+    RtlInitUnicodeString( &titleW, startup->lpTitle ? startup->lpTitle : imagepath );
+    RtlInitUnicodeString( &desktopW, startup->lpDesktop );
+    runtimeW.Buffer = (WCHAR *)startup->lpReserved2;
+    runtimeW.Length = runtimeW.MaximumLength = startup->cbReserved2;
+    if (RtlCreateProcessParametersEx( &params, &imageW, NULL, cur_dir ? &curdirW : NULL,
+                                      &cmdlineW, envW, &titleW, &desktopW,
+                                      NULL, &runtimeW, PROCESS_PARAMS_FLAG_NORMALIZED ))
+    {
+        RtlFreeUnicodeString( &newdirW );
+        if (envW != env) RtlFreeHeap( GetProcessHeap(), 0, envW );
+        return NULL;
+    }
+    RtlFreeUnicodeString( &newdirW );
+
+    if (!(flags & CREATE_NEW_PROCESS_GROUP))
+        params->ProcessGroupId = NtCurrentTeb()->Peb->ProcessParameters->ProcessGroupId;
+    else if (!(flags & CREATE_NEW_CONSOLE))
+        params->ConsoleFlags = 1;
+
+    if (flags & CREATE_NEW_CONSOLE) params->ConsoleHandle = CONSOLE_HANDLE_ALLOC;
+    else if (!(flags & DETACHED_PROCESS))
+    {
+        if (flags & CREATE_NO_WINDOW) params->ConsoleHandle = CONSOLE_HANDLE_ALLOC_NO_WINDOW;
+        else
+        {
+            params->ConsoleHandle = NtCurrentTeb()->Peb->ProcessParameters->ConsoleHandle;
+            if (!params->ConsoleHandle) params->ConsoleHandle = CONSOLE_HANDLE_ALLOC;
+        }
+    }
+
+    if (startup->dwFlags & STARTF_USESTDHANDLES)
+    {
+        params->hStdInput  = startup->hStdInput;
+        params->hStdOutput = startup->hStdOutput;
+        params->hStdError  = startup->hStdError;
+    }
+    else if (!(flags & (DETACHED_PROCESS | CREATE_NEW_CONSOLE)))
+    {
+        params->hStdInput  = NtCurrentTeb()->Peb->ProcessParameters->hStdInput;
+        params->hStdOutput = NtCurrentTeb()->Peb->ProcessParameters->hStdOutput;
+        params->hStdError  = NtCurrentTeb()->Peb->ProcessParameters->hStdError;
+    }
+
+    if (params->hStdInput  == INVALID_HANDLE_VALUE) params->hStdInput  = NULL;
+    if (params->hStdOutput == INVALID_HANDLE_VALUE) params->hStdOutput = NULL;
+    if (params->hStdError  == INVALID_HANDLE_VALUE) params->hStdError  = NULL;
+
+    params->dwX             = startup->dwX;
+    params->dwY             = startup->dwY;
+    params->dwXSize         = startup->dwXSize;
+    params->dwYSize         = startup->dwYSize;
+    params->dwXCountChars   = startup->dwXCountChars;
+    params->dwYCountChars   = startup->dwYCountChars;
+    params->dwFillAttribute = startup->dwFillAttribute;
+    params->dwFlags         = startup->dwFlags;
+    params->wShowWindow     = startup->wShowWindow;
+
+    if (envW != env) RtlFreeHeap( GetProcessHeap(), 0, envW );
+    return params;
+}
+
+ 
+ struct proc_thread_attr
+{
+    DWORD_PTR attr;
+    SIZE_T size;
+    void *value;
+};
+
+struct _PROC_THREAD_ATTRIBUTE_LIST
+{
+    DWORD mask;  /* bitmask of items in list */
+    DWORD size;  /* max number of items in list */
+    DWORD count; /* number of items in list */
+    DWORD pad;
+    DWORD_PTR unk;
+    struct proc_thread_attr attrs[1];
+};
+
+ 
+/***********************************************************************
+ *           create_nt_process
+ */
+static NTSTATUS create_nt_process( HANDLE token, HANDLE debug, SECURITY_ATTRIBUTES *psa,
+                                   SECURITY_ATTRIBUTES *tsa, DWORD process_flags,
+                                   RTL_USER_PROCESS_PARAMETERS *params,
+                                   RTL_USER_PROCESS_INFORMATION *info,
+                                   HANDLE parent, USHORT machine,
+                                   const struct proc_thread_attr *handle_list,
+                                   const struct proc_thread_attr *job_list)
+{
+    OBJECT_ATTRIBUTES process_attr, thread_attr;
+    PS_CREATE_INFO create_info;
+    ULONG_PTR buffer[offsetof( PS_ATTRIBUTE_LIST, Attributes[9] ) / sizeof(ULONG_PTR)];
+    PS_ATTRIBUTE_LIST *attr = (PS_ATTRIBUTE_LIST *)buffer;
+    UNICODE_STRING nameW;
+    NTSTATUS status;
+    UINT pos = 0;
+
+    if (!params->ImagePathName.Buffer[0]) return STATUS_OBJECT_PATH_NOT_FOUND;
+    status = RtlDosPathNameToNtPathName_U_WithStatus( params->ImagePathName.Buffer, &nameW, NULL, NULL );
+    if (!status)
+    {
+        RtlNormalizeProcessParams( params );
+
+        attr->Attributes[pos].Attribute    = PS_ATTRIBUTE_IMAGE_NAME;
+        attr->Attributes[pos].Size         = nameW.Length;
+        attr->Attributes[pos].ValuePtr     = nameW.Buffer;
+        attr->Attributes[pos].ReturnLength = NULL;
+        pos++;
+        attr->Attributes[pos].Attribute    = PS_ATTRIBUTE_CLIENT_ID;
+        attr->Attributes[pos].Size         = sizeof(info->ClientId);
+        attr->Attributes[pos].ValuePtr     = &info->ClientId;
+        attr->Attributes[pos].ReturnLength = NULL;
+        pos++;
+        attr->Attributes[pos].Attribute    = PS_ATTRIBUTE_IMAGE_INFO;
+        attr->Attributes[pos].Size         = sizeof(info->ImageInformation);
+        attr->Attributes[pos].ValuePtr     = &info->ImageInformation;
+        attr->Attributes[pos].ReturnLength = NULL;
+        pos++;
+        if (parent)
+        {
+            attr->Attributes[pos].Attribute    = PS_ATTRIBUTE_PARENT_PROCESS;
+            attr->Attributes[pos].Size         = sizeof(parent);
+            attr->Attributes[pos].ValuePtr     = parent;
+            attr->Attributes[pos].ReturnLength = NULL;
+            pos++;
+        }
+        if ((process_flags & PROCESS_CREATE_FLAGS_INHERIT_HANDLES) && handle_list)
+        {
+            attr->Attributes[pos].Attribute    = PS_ATTRIBUTE_HANDLE_LIST;
+            attr->Attributes[pos].Size         = handle_list->size;
+            attr->Attributes[pos].ValuePtr     = handle_list->value;
+            attr->Attributes[pos].ReturnLength = NULL;
+            pos++;
+        }
+        if (token)
+        {
+            attr->Attributes[pos].Attribute    = PS_ATTRIBUTE_TOKEN;
+            attr->Attributes[pos].Size         = sizeof(token);
+            attr->Attributes[pos].ValuePtr     = token;
+            attr->Attributes[pos].ReturnLength = NULL;
+            pos++;
+        }
+        if (debug)
+        {
+            attr->Attributes[pos].Attribute    = PS_ATTRIBUTE_DEBUG_PORT;
+            attr->Attributes[pos].Size         = sizeof(debug);
+            attr->Attributes[pos].ValuePtr     = debug;
+            attr->Attributes[pos].ReturnLength = NULL;
+            pos++;
+        }
+        if (job_list)
+        {
+            attr->Attributes[pos].Attribute    = PS_ATTRIBUTE_JOB_LIST;
+            attr->Attributes[pos].Size         = job_list->size;
+            attr->Attributes[pos].ValuePtr     = job_list->value;
+            attr->Attributes[pos].ReturnLength = NULL;
+            pos++;
+        }
+        if (machine)
+        {
+            attr->Attributes[pos].Attribute    = PS_ATTRIBUTE_MACHINE_TYPE;
+            attr->Attributes[pos].Size         = sizeof(machine);
+            attr->Attributes[pos].Value        = machine;
+            attr->Attributes[pos].ReturnLength = NULL;
+            pos++;
+        }
+        attr->TotalLength = offsetof( PS_ATTRIBUTE_LIST, Attributes[pos] );
+
+        InitializeObjectAttributes( &process_attr, NULL, 0, NULL, psa ? psa->lpSecurityDescriptor : NULL );
+        InitializeObjectAttributes( &thread_attr, NULL, 0, NULL, tsa ? tsa->lpSecurityDescriptor : NULL );
+
+        status = NtCreateUserProcess( &info->Process, &info->Thread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS,
+                                      &process_attr, &thread_attr, process_flags,
+                                      THREAD_CREATE_FLAGS_CREATE_SUSPENDED, params,
+                                      &create_info, attr );
+
+        RtlFreeUnicodeString( &nameW );
+    }
+    return status;
+}
+
+
+/***********************************************************************
+ *           create_vdm_process
+ */
+static NTSTATUS create_vdm_process( HANDLE token, HANDLE debug, SECURITY_ATTRIBUTES *psa,
+                                    SECURITY_ATTRIBUTES *tsa, DWORD flags,
+                                    RTL_USER_PROCESS_PARAMETERS *params,
+                                    RTL_USER_PROCESS_INFORMATION *info )
+{
+	
+	BOOL is_wow64 = FALSE;
+    IsWow64Process( GetCurrentProcess(), &is_wow64 );
+
+    const WCHAR *winevdm = (is_win64 || is_wow64 ?
+                            L"C:\\windows\\syswow64\\winevdm.exe" :
+                            L"C:\\windows\\system32\\winevdm.exe");
+    WCHAR *newcmdline;
+    NTSTATUS status;
+    UINT len;
+
+    len = (lstrlenW(params->ImagePathName.Buffer) + lstrlenW(params->CommandLine.Buffer) +
+           lstrlenW(winevdm) + 16);
+
+    if (!(newcmdline = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
+        return STATUS_NO_MEMORY;
+
+    swprintf( newcmdline, len, L"%s --app-name \"%s\" %s",
+              winevdm, params->ImagePathName.Buffer, params->CommandLine.Buffer );
+    RtlInitUnicodeString( &params->ImagePathName, winevdm );
+    RtlInitUnicodeString( &params->CommandLine, newcmdline );
+    status = create_nt_process( token, debug, psa, tsa, flags, params, info, 0, 0, NULL, NULL );
+    HeapFree( GetProcessHeap(), 0, newcmdline );
+    return status;
+}
+
+
+/***********************************************************************
+ *           create_cmd_process
+ */
+static NTSTATUS create_cmd_process( HANDLE token, HANDLE debug, SECURITY_ATTRIBUTES *psa,
+                                    SECURITY_ATTRIBUTES *tsa, DWORD flags,
+                                    RTL_USER_PROCESS_PARAMETERS *params,
+                                    RTL_USER_PROCESS_INFORMATION *info )
+{
+    WCHAR comspec[MAX_PATH];
+    WCHAR *newcmdline;
+    NTSTATUS status;
+    UINT len;
+
+    if (!GetEnvironmentVariableW( L"COMSPEC", comspec, ARRAY_SIZE( comspec )))
+        lstrcpyW( comspec, L"C:\\windows\\system32\\cmd.exe" );
+
+    len = lstrlenW(comspec) + 7 + lstrlenW(params->CommandLine.Buffer) + 2;
+    if (!(newcmdline = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
+        return STATUS_NO_MEMORY;
+
+    swprintf( newcmdline, len, L"%s /s/c \"%s\"", comspec, params->CommandLine.Buffer );
+    RtlInitUnicodeString( &params->ImagePathName, comspec );
+    RtlInitUnicodeString( &params->CommandLine, newcmdline );
+    status = create_nt_process( token, debug, psa, tsa, flags, params, info, 0, 0, NULL, NULL );
+    RtlFreeHeap( GetProcessHeap(), 0, newcmdline );
+    return status;
+}
+
+ 
+ 
+ /**********************************************************************
+ *           CreateProcessInternalW   (kernelbase.@)
+ */
+BOOL WINAPI DECLSPEC_HOTPATCH CreateProcessInternalW( HANDLE token, const WCHAR *app_name, WCHAR *cmd_line,
+                                                      SECURITY_ATTRIBUTES *process_attr,
+                                                      SECURITY_ATTRIBUTES *thread_attr,
+                                                      BOOL inherit, DWORD flags, void *env,
+                                                      const WCHAR *cur_dir, STARTUPINFOW *startup_info,
+                                                      PROCESS_INFORMATION *info, HANDLE *new_token )
+{
+    const struct proc_thread_attr *handle_list = NULL, *job_list = NULL;
+    WCHAR name[MAX_PATH];
+    WCHAR *p, *tidy_cmdline = cmd_line;
+    RTL_USER_PROCESS_PARAMETERS *params = NULL;
+    RTL_USER_PROCESS_INFORMATION rtl_info;
+    HANDLE parent = 0, debug = 0;
+    ULONG nt_flags = 0;
+    USHORT machine = 0;
+    NTSTATUS status;
+
+    /* Process the AppName and/or CmdLine to get module name and path */
+
+    TRACE( "app %s cmdline %s\n", debugstr_w(app_name), debugstr_w(cmd_line) );
+
+    if (new_token) FIXME( "No support for returning created process token\n" );
+
+    if (app_name)
+    {
+        if (!cmd_line || !cmd_line[0]) /* no command-line, create one */
+        {
+            if (!(tidy_cmdline = RtlAllocateHeap( GetProcessHeap(), 0, (lstrlenW(app_name)+3) * sizeof(WCHAR) )))
+                return FALSE;
+            swprintf( tidy_cmdline, lstrlenW(app_name) + 3, L"\"%s\"", app_name );
+        }
+    }
+    else
+    {
+        if (!(tidy_cmdline = get_file_name( cmd_line, name, ARRAY_SIZE(name) ))) return FALSE;
+        app_name = name;
+    }
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+    WCHAR ini_path[MAX_PATH];
+
+    ExpandEnvironmentStringsW( L"%ProgramData%\\Chocolatey-for-wine\\kernel32.ini", ini_path, MAX_PATH + 1 );
+
+    if(GetFileAttributesW(ini_path) != INVALID_FILE_ATTRIBUTES) {
+        static HINSTANCE hkernel32;
+        static DWORD   (WINAPI *pGetPrivateProfileStringW)(LPCWSTR a, LPCWSTR b, LPCWSTR c, LPWSTR d, DWORD e, LPCWSTR f);
+ 
+        hkernel32 = GetModuleHandleA("kernel32");
+         pGetPrivateProfileStringW = (void *) GetProcAddress(hkernel32, "GetPrivateProfileStringW");
+
+         WCHAR new_cmd_line[MAX_PATH];
+ 
+        if(pGetPrivateProfileStringW((wcsrchr(app_name,L'\\')+1), 0, 0 , new_cmd_line,sizeof(new_cmd_line), ini_path)) {
+ 
+            FIXME( "app %s cmdline to be replaced %s\n", debugstr_w(app_name), debugstr_w(tidy_cmdline) );
+    
+            if(pGetPrivateProfileStringW((wcsrchr(app_name,L'\\')+1), L"append", 0 , new_cmd_line,sizeof(new_cmd_line), ini_path)) 
+                wcscat( wcscat(tidy_cmdline, L" "), new_cmd_line); 
+
+            if(pGetPrivateProfileStringW((wcsrchr(app_name,L'\\')+1), L"replace_from", 0 , new_cmd_line,sizeof(new_cmd_line), ini_path)) {
+
+		        if(!wcsicmp( tidy_cmdline + wcslen(app_name)+3, new_cmd_line ) ){
+
+                    if(pGetPrivateProfileStringW((wcsrchr(app_name,L'\\')+1), L"replace_to", 0 , new_cmd_line,sizeof(new_cmd_line), ini_path))
+                    {   tidy_cmdline[wcslen(app_name)+3]=0;   wcscat(tidy_cmdline, new_cmd_line);}
+	            }
+            }    
+    
+            FIXME( "app %s replaced cmdline  %s\n", debugstr_w(app_name), debugstr_w(cmd_line) );
+        }
+    }
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+    /* Warn if unsupported features are used */
+
+    if (flags & (IDLE_PRIORITY_CLASS | HIGH_PRIORITY_CLASS | REALTIME_PRIORITY_CLASS |
+                 CREATE_DEFAULT_ERROR_MODE | PROFILE_USER | PROFILE_KERNEL | PROFILE_SERVER))
+        WARN( "(%s,...): ignoring some flags in %lx\n", debugstr_w(app_name), flags );
+
+    if (cur_dir)
+    {
+        DWORD attr = GetFileAttributesW( cur_dir );
+        if (attr == INVALID_FILE_ATTRIBUTES || !(attr & FILE_ATTRIBUTE_DIRECTORY))
+        {
+            status = STATUS_NOT_A_DIRECTORY;
+            goto done;
+        }
+    }
+
+    info->hThread = info->hProcess = 0;
+    info->dwProcessId = info->dwThreadId = 0;
+
+    if (!(params = create_process_params( app_name, tidy_cmdline, cur_dir, env, flags, startup_info )))
+    {
+        status = STATUS_NO_MEMORY;
+        goto done;
+    }
+
+    if (flags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS))
+    {
+        if ((status = DbgUiConnectToDbg())) goto done;
+        debug = DbgUiGetThreadDebugObject();
+    }
+
+    if (flags & EXTENDED_STARTUPINFO_PRESENT)
+    {
+        struct _PROC_THREAD_ATTRIBUTE_LIST *attrs =
+                (struct _PROC_THREAD_ATTRIBUTE_LIST *)((STARTUPINFOEXW *)startup_info)->lpAttributeList;
+        unsigned int i;
+
+        if (attrs)
+        {
+            for (i = 0; i < attrs->count; ++i)
+            {
+                switch(attrs->attrs[i].attr)
+                {
+                    case PROC_THREAD_ATTRIBUTE_PARENT_PROCESS:
+                        parent = *(HANDLE *)attrs->attrs[i].value;
+                        TRACE("PROC_THREAD_ATTRIBUTE_PARENT_PROCESS parent %p.\n", parent);
+                        if (!parent)
+                        {
+                            status = STATUS_INVALID_HANDLE;
+                            goto done;
+                        }
+                        break;
+                    case PROC_THREAD_ATTRIBUTE_HANDLE_LIST:
+                        handle_list = &attrs->attrs[i];
+                        TRACE("PROC_THREAD_ATTRIBUTE_HANDLE_LIST handle count %Iu.\n", attrs->attrs[i].size / sizeof(HANDLE));
+                        break;
+                    case PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE:
+                        {
+                            struct pseudo_console *console = attrs->attrs[i].value;
+                            TRACE( "PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE %p reference %p\n",
+                                   console, console->reference );
+                            params->ConsoleHandle = console->reference;
+                            break;
+                        }
+                    case PROC_THREAD_ATTRIBUTE_JOB_LIST:
+                        job_list = &attrs->attrs[i];
+                        TRACE( "PROC_THREAD_ATTRIBUTE_JOB_LIST handle count %Iu.\n",
+                               attrs->attrs[i].size / sizeof(HANDLE) );
+                        break;
+                    case PROC_THREAD_ATTRIBUTE_MACHINE_TYPE:
+                        machine = *(USHORT *)attrs->attrs[i].value;
+                        TRACE( "PROC_THREAD_ATTRIBUTE_MACHINE %x.\n", machine );
+                        break;
+                    default:
+                        FIXME("Unsupported attribute %#Ix.\n", attrs->attrs[i].attr);
+                        break;
+                }
+            }
+        }
+    }
+
+    if (inherit) nt_flags |= PROCESS_CREATE_FLAGS_INHERIT_HANDLES;
+    if (flags & DEBUG_ONLY_THIS_PROCESS) nt_flags |= PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT;
+    if (flags & CREATE_BREAKAWAY_FROM_JOB) nt_flags |= PROCESS_CREATE_FLAGS_BREAKAWAY;
+    if (flags & CREATE_SUSPENDED) nt_flags |= PROCESS_CREATE_FLAGS_SUSPENDED;
+
+    status = create_nt_process( token, debug, process_attr, thread_attr,
+                                nt_flags, params, &rtl_info, parent, machine, handle_list, job_list );
+    switch (status)
+    {
+    case STATUS_SUCCESS:
+        break;
+    case STATUS_INVALID_IMAGE_WIN_16:
+    case STATUS_INVALID_IMAGE_NE_FORMAT:
+    case STATUS_INVALID_IMAGE_PROTECT:
+        TRACE( "starting %s as Win16/DOS binary\n", debugstr_w(app_name) );
+        status = create_vdm_process( token, debug, process_attr, thread_attr,
+                                     nt_flags, params, &rtl_info );
+        break;
+    case STATUS_INVALID_IMAGE_NOT_MZ:
+        /* check for .com or .bat extension */
+        if (!(p = wcsrchr( app_name, '.' ))) break;
+        if (!wcsicmp( p, L".com" ) || !wcsicmp( p, L".pif" ))
+        {
+            TRACE( "starting %s as DOS binary\n", debugstr_w(app_name) );
+            status = create_vdm_process( token, debug, process_attr, thread_attr,
+                                         nt_flags, params, &rtl_info );
+        }
+        else if (!wcsicmp( p, L".bat" ) || !wcsicmp( p, L".cmd" ))
+        {
+            TRACE( "starting %s as batch binary\n", debugstr_w(app_name) );
+            status = create_cmd_process( token, debug, process_attr, thread_attr,
+                                         nt_flags, params, &rtl_info );
+        }
+        break;
+    }
+
+    if (!status)
+    {
+        info->hProcess    = rtl_info.Process;
+        info->hThread     = rtl_info.Thread;
+        info->dwProcessId = HandleToUlong( rtl_info.ClientId.UniqueProcess );
+        info->dwThreadId  = HandleToUlong( rtl_info.ClientId.UniqueThread );
+        if (!(flags & CREATE_SUSPENDED)) NtResumeThread( rtl_info.Thread, NULL );
+        TRACE( "started process pid %04lx tid %04lx\n", info->dwProcessId, info->dwThreadId );
+    }
+
+ done:
+    RtlDestroyProcessParameters( params );
+    if (tidy_cmdline != cmd_line) HeapFree( GetProcessHeap(), 0, tidy_cmdline );
+    return set_ntstatus( status );
+}
+
diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 7ed8048f5d0..5c25582f20d 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -319,9 +319,9 @@
 @ stdcall -import CreateProcessAsUserA(long str str ptr ptr long long ptr str ptr ptr)
 @ stdcall -import CreateProcessAsUserW(long wstr wstr ptr ptr long long ptr wstr ptr ptr)
 @ stdcall -import CreateProcessInternalA(long str str ptr ptr long long ptr str ptr ptr ptr)
-@ stdcall -import CreateProcessInternalW(long wstr wstr ptr ptr long long ptr wstr ptr ptr ptr)
+@ stdcall CreateProcessInternalW(long wstr wstr ptr ptr long long ptr wstr ptr ptr ptr)
 # @ stub CreateProcessInternalWSecure
-@ stdcall -import CreateProcessW(wstr wstr ptr ptr long long ptr wstr ptr ptr)
+@ stdcall CreateProcessW(wstr wstr ptr ptr long long ptr wstr ptr ptr)
 @ stdcall -import CreatePseudoConsole(long long long long ptr)
 @ stdcall -import CreateRemoteThread(long ptr long ptr long long ptr)
 @ stdcall -import CreateRemoteThreadEx(long ptr long ptr ptr long ptr ptr)
@@ -514,7 +514,7 @@
 @ stdcall -import FindNLSStringEx(wstr long wstr long wstr long ptr ptr ptr long)
 @ stdcall FindResourceA(long str str)
 @ stdcall FindResourceExA(long str str long)
-@ stdcall -import FindResourceExW(long wstr wstr long)
+@ stdcall FindResourceExW(long wstr wstr long)
 @ stdcall -import FindResourceW(long wstr wstr)
 @ stdcall -import FindStringOrdinal(long wstr long wstr long long)
 @ stdcall -import FindVolumeClose(ptr)
@@ -536,7 +536,7 @@
 @ stdcall -import FreeEnvironmentStringsA(ptr)
 @ stdcall -import FreeEnvironmentStringsW(ptr)
 @ stub -i386 FreeLSCallback
-@ stdcall -import FreeLibrary(long)
+@ stdcall FreeLibrary(long)
 @ stdcall FreeLibraryAndExitThread(long long)
 @ stdcall FreeLibraryWhenCallbackReturns(ptr ptr) NTDLL.TpCallbackUnloadDllOnCompletion
 @ stdcall -import FreeResource(long)
@@ -1073,7 +1073,7 @@
 @ stdcall -import LoadLibraryW(wstr)
 @ stdcall LoadModule(str ptr)
 @ stdcall -import LoadPackagedLibrary(wstr long)
-@ stdcall -import LoadResource(long long)
+@ stdcall LoadResource(long long)
 # @ stub LoadStringBaseExW
 # @ stub LoadStringBaseW
 @ stdcall -import LocalAlloc(long long)
@@ -1603,7 +1603,7 @@
 @ stdcall -import VirtualFree(ptr long long)
 @ stdcall -import VirtualFreeEx(long ptr long long)
 @ stdcall -import VirtualLock(ptr long)
-@ stdcall -import VirtualProtect(ptr long long ptr)
+@ stdcall VirtualProtect(ptr long long ptr)
 @ stdcall -import VirtualProtectEx(long ptr long long ptr)
 @ stdcall -import VirtualQuery(ptr ptr long)
 @ stdcall -import VirtualQueryEx(long ptr ptr long)
